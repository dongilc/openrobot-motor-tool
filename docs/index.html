<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenRobot Motor CAN Protocol — OpenRobot MC v11</title>
<style>
  :root {
    --primary: #1a5276;
    --primary-light: #2980b9;
    --accent: #e74c3c;
    --bg: #ffffff;
    --bg-alt: #f8f9fa;
    --border: #dee2e6;
    --text: #2c3e50;
    --text-light: #6c757d;
    --code-bg: #eef1f5;
    --warning-bg: #fff3cd;
    --warning-border: #ffc107;
    --new-bg: #d4edda;
    --new-border: #28a745;
    --info-bg: #d1ecf1;
    --info-border: #17a2b8;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
    color: var(--text);
    line-height: 1.6;
    max-width: 960px;
    margin: 0 auto;
    padding: 40px 30px;
    background: var(--bg);
  }

  /* Header */
  .doc-header {
    border-bottom: 3px solid var(--primary);
    padding-bottom: 20px;
    margin-bottom: 30px;
  }
  .doc-header h1 {
    font-size: 28px;
    color: var(--primary);
    margin-bottom: 4px;
  }
  .doc-header .subtitle {
    font-size: 14px;
    color: var(--text-light);
  }
  .doc-header .version-info {
    margin-top: 10px;
    font-size: 13px;
    color: var(--text-light);
    background: var(--bg-alt);
    padding: 8px 14px;
    border-radius: 4px;
    border-left: 3px solid var(--primary-light);
  }

  /* Sections */
  h2 {
    font-size: 22px;
    color: var(--primary);
    margin-top: 40px;
    margin-bottom: 16px;
    padding-bottom: 6px;
    border-bottom: 2px solid var(--primary-light);
  }
  h3 {
    font-size: 17px;
    color: var(--primary);
    margin-top: 28px;
    margin-bottom: 10px;
  }
  h3 .cmd-id {
    display: inline-block;
    background: var(--primary);
    color: #fff;
    padding: 2px 10px;
    border-radius: 4px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 15px;
    margin-right: 6px;
  }
  h3 .new-badge {
    display: inline-block;
    background: var(--new-border);
    color: #fff;
    padding: 1px 8px;
    border-radius: 10px;
    font-size: 11px;
    font-weight: 600;
    vertical-align: middle;
    margin-left: 6px;
  }
  h4 {
    font-size: 15px;
    color: var(--primary);
    margin-top: 20px;
    margin-bottom: 8px;
  }

  /* Tables */
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 12px 0 16px;
    font-size: 14px;
  }
  th, td {
    padding: 8px 12px;
    text-align: left;
    border: 1px solid var(--border);
  }
  th {
    background: var(--primary);
    color: #fff;
    font-weight: 600;
    font-size: 13px;
    white-space: nowrap;
  }
  tr:nth-child(even) { background: var(--bg-alt); }
  tr:hover { background: #e8f0fe; }

  /* Summary table special styling */
  .summary-table tr.new-row { background: var(--new-bg); font-weight: 600; }
  .summary-table tr.new-row:hover { background: #b8e6c4; }
  .summary-table .type-read { color: #2980b9; font-weight: 600; }
  .summary-table .type-write { color: #e67e22; font-weight: 600; }
  .summary-table .type-control { color: #27ae60; font-weight: 600; }

  /* Code */
  code {
    font-family: 'Consolas', 'Courier New', monospace;
    background: var(--code-bg);
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 13px;
    color: #c0392b;
  }
  .tx-frame {
    display: block;
    background: var(--code-bg);
    padding: 10px 16px;
    border-radius: 4px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 13px;
    margin: 8px 0;
    border-left: 3px solid var(--primary-light);
    overflow-x: auto;
  }
  .tx-label {
    font-weight: 700;
    color: var(--primary);
    margin-right: 4px;
  }

  /* Descriptions */
  p { margin: 6px 0; font-size: 14px; }
  .cmd-desc {
    color: var(--text-light);
    font-size: 14px;
    margin-bottom: 10px;
  }

  /* Warning box */
  .warning {
    background: var(--warning-bg);
    border: 1px solid var(--warning-border);
    border-left: 4px solid var(--warning-border);
    padding: 10px 16px;
    border-radius: 4px;
    margin: 10px 0;
    font-size: 13px;
  }
  .warning::before {
    content: "\26A0\FE0F";
    margin-right: 6px;
  }

  /* Info box */
  .info {
    background: var(--info-bg);
    border: 1px solid var(--info-border);
    border-left: 4px solid var(--info-border);
    padding: 10px 16px;
    border-radius: 4px;
    margin: 10px 0;
    font-size: 13px;
  }

  /* New feature box */
  .new-box {
    background: var(--new-bg);
    border: 1px solid var(--new-border);
    border-left: 4px solid var(--new-border);
    padding: 10px 16px;
    border-radius: 4px;
    margin: 10px 0;
    font-size: 13px;
  }

  /* Note box (Korean explanations) */
  .note-box {
    background: #f0f4ff;
    border: 1px solid #b8c9e8;
    border-left: 4px solid #5b7db1;
    padding: 10px 16px;
    border-radius: 4px;
    margin: 10px 0;
    font-size: 13px;
    line-height: 1.7;
  }
  .note-box .note-title {
    font-weight: 700;
    color: var(--primary);
    margin-bottom: 4px;
  }

  /* Separator */
  hr {
    border: none;
    border-top: 1px solid var(--border);
    margin: 24px 0;
  }

  /* Fault code table */
  .fault-table td:first-child {
    text-align: center;
    font-family: 'Consolas', monospace;
    font-weight: 600;
    width: 60px;
  }

  /* Terminal command block */
  .terminal {
    background: #1e1e1e;
    color: #d4d4d4;
    padding: 14px 18px;
    border-radius: 6px;
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.8;
    margin: 10px 0;
    overflow-x: auto;
  }
  .terminal .prompt { color: #6a9955; }
  .terminal .comment { color: #6a9955; }

  /* Control formula */
  .formula {
    background: var(--bg-alt);
    border: 1px solid var(--border);
    padding: 10px 16px;
    border-radius: 4px;
    font-family: 'Consolas', monospace;
    font-size: 13px;
    margin: 8px 0;
    text-align: center;
  }

  /* Change log */
  .changelog {
    font-size: 13px;
    line-height: 1.8;
  }
  .changelog h4 {
    color: var(--primary);
    font-size: 14px;
    margin-top: 14px;
    margin-bottom: 4px;
  }
  .changelog ul { margin-left: 20px; margin-bottom: 8px; }
  .changelog li { margin-bottom: 2px; }
  .changelog .important {
    background: #ffeaa7;
    padding: 6px 12px;
    border-radius: 4px;
    margin: 6px 0;
    font-weight: 600;
  }

  /* Revision history */
  .revision-table td:first-child {
    font-weight: 700;
    color: var(--primary);
    white-space: nowrap;
  }
  .revision-table td:nth-child(2) { white-space: nowrap; }

  /* Footer */
  .doc-footer {
    margin-top: 50px;
    padding-top: 16px;
    border-top: 2px solid var(--border);
    font-size: 12px;
    color: var(--text-light);
    text-align: center;
  }

  /* General info table */
  .general-table th { width: 160px; }
  .general-table td code { font-size: 14px; }

  /* Setup steps */
  .setup-steps { font-size: 14px; line-height: 1.8; }
  .setup-steps ol { margin-left: 20px; }
  .setup-steps li { margin-bottom: 6px; }

  /* Print styles */
  @media print {
    body { padding: 20px; max-width: 100%; }
    h2, h3 { page-break-after: avoid; }
    table { page-break-inside: avoid; }
    .warning, .info, .new-box, .note-box { page-break-inside: avoid; }
  }
</style>
</head>
<body>

<!-- ============================================================ -->
<!-- HEADER -->
<!-- ============================================================ -->
<div class="doc-header">
  <h1>OpenRobot Motor CAN Protocol</h1>
  <div class="subtitle">OpenRobot MC Custom Firmware &mdash; CAN Communication Specification</div>
  <div class="version-info">
    <strong>Version 11</strong> &mdash; 2026-02-23 &nbsp;|&nbsp; by Dongil Choi, Hur Seongyoung
  </div>
</div>

<!-- ============================================================ -->
<!-- CHANGE LOGS -->
<!-- ============================================================ -->
<h2>Change Logs</h2>

<div class="changelog">
  <h4>24-11-13</h4>
  <ul>
    <li>encoder offset 반영 (원점 세팅에 유리하게)</li>
    <li>torque control에 damping 기능 추가</li>
    <li>fault code 읽을 수 있게 함</li>
  </ul>

  <h4>24-11-18</h4>
  <ul>
    <li>current limit 값 읽고 수정할 수 있게 함</li>
    <li>fault code를 7개까지 읽을 수 있게 함 (최근 7개)</li>
    <li>(TODO) RMD-x6-s2 에서 Motor Curr. Max 값이 대게 20A이하로 설정되어 있는데 이것을 50A이상 설정하면 위치제어시 진동발생(토크제어는 영향 없음) — 현재는 Motor Curr. Max 값을 자동 설정된 값 이상으로 바꾸는 것은 비추천</li>
  </ul>

  <h4>24-12-12 (서울과기대, 국민대 방문, 요구사항 수렴)</h4>
  <ul>
    <li>fault code시 해당 모터 정지하고, 전체 스탑은 상위컴에서 제어 (서울과기대 요청) &mdash; TODO</li>
    <li>CAN으로 펌웨어 업데이트 한번에 가능하게 (서울과기대, 국민대 요청) &mdash; TODO</li>
    <li>토크전류 리밋 CAN으로 설정 (국민대 요청) &mdash; 해결함 (Write Max Current to ROM)</li>
    <li>모터튜닝파라미터 CAN으로 설정 (국민대 요청) &mdash; TODO</li>
  </ul>

  <h4>25-01-14</h4>
  <ul>
    <li>fault code시 해당 모터 정지하고, 전체 스탑은 상위컴에서 제어 (서울과기대 요청) &mdash; TODO</li>
    <li>CAN으로 펌웨어 업데이트 한번에 가능하게 (서울과기대, 국민대 요청) &mdash; 적용완료</li>
    <li>토크전류 리밋 CAN으로 설정 (국민대 요청) &mdash; 적용완료 (Write Max Current to ROM)</li>
    <li>모터튜닝파라미터 CAN으로 설정 (국민대 요청) &mdash; 적용완료 (VESC-Tool에서 CAN Forward 기능사용)</li>
    <li>토크제어시 Damping 제어기능 수정보완 완료</li>
  </ul>

  <div class="important">변경사항: MOTOR_OFF, MOTOR_STOP, MOTOR_START, TORQUE_CLOSED_LOOP, SPEED_CLOSED_LOOP, POSITION_CLOSED_LOOP, SET_MULTITURN_POSITION 제어 모두 한번 명령을 전달하면 그 값이 유지되는 것으로 바꿈. 기존엔 몇몇 제어는 반복적으로 명령을 보내줘야만 제어가 유지되던 것을 일괄적으로 1회 전달된 명령이 유지되는 것으로 바꾸었음.</div>

  <h4>25-05-15</h4>
  <ul>
    <li>Set multiturn pos 를 이용한 위치제어가 offset error 가 해결될 수 없는 구조로 되어 있음을 발견, 이를 해결하기위해 Position closed-loop1 을 multiturn 방식으로 바꾸고, dps_limit 없이 직접 PID 제어되도록 수정함. &rarr; PID 제어시에는 Position closed-loop1 을 사용하기를 추천함</li>
  </ul>

  <h4>26-02-09 (v9)</h4>
  <ul>
    <li><code>0x9C</code> (Read Motor Status 2) 추가 &mdash; 모터 동작에 영향 없는 상태 읽기 전용 명령. 실시간 모니터링/데이터 로깅용.</li>
    <li><code>0x9D</code> (Read Motor Status 3) 추가 &mdash; Control Mode + Phase A/B/C 전류 읽기. Inverse Clarke 변환으로 상전류 계산.</li>
    <li><code>or_limit</code> 안전 리미터 추가 &mdash; 0xA3 대용량 위치 스텝시 과전류 보호 (REDIRECT / RAMP 두 가지 모드)</li>
    <li>Encoder 14-bit 정규화 &mdash; MT6835 (21-bit) 엔코더를 14-bit (0&ndash;16383) 범위로 정규화. CNT2DEG = 360/16384.</li>
    <li><code>0xA2</code> Speed Closed-Loop에 <strong>speed_mode</strong> 추가 (DATA[1]) &mdash; DPS 제어(mode=0, 기존)와 eRPM 제어(mode=1, VESC 내장 PID) 두 가지 속도제어 모드 선택 가능. 기존 DATA[1]=0x00으로 전송하던 코드는 변경 없이 DPS 모드로 동작 (하위 호환).</li>
  </ul>

  <h4>26-02-11 (v10)</h4>
  <ul>
    <li><strong>VESC EID Protocol 섹션 추가</strong> &mdash; CAN Extended ID를 통한 VESC 명령 프로토콜 (MCCONF 읽기/쓰기, 리부트, 펌웨어 업로드) 문서화</li>
    <li><strong>Encoder native resolution</strong> &mdash; AS5047 (14-bit, 16384 CPR) / MT6835 (21-bit, 2097152 CPR) 네이티브 해상도 지원. CAN SID 프레임에서는 14-bit로 정규화하여 전송 (하위 호환). <code>uint64_t</code> 캐스트로 오버플로 방지.</li>
    <li><strong>COMM_REBOOT 버그 수정</strong> &mdash; IWDG 리셋 후 CAN 초기화 전 fault broadcast로 인한 HardFault 수정. <code>comm_can_is_ready()</code> 가드 추가.</li>
    <li><strong>CAN 펌웨어/부트로더 업로드</strong> &mdash; VESC EID를 통한 펌웨어 및 부트로더 바이너리 업로드 지원</li>
    <li><strong>Position/Speed PID via MCCONF</strong> &mdash; VESC EID로 Position PID (Kp/Ki/Kd/Kd Filter) 및 Speed PID (Kp/Ki/Kd/Kd Filter/Ramp) 직접 읽기/쓰기</li>
  </ul>

  <h4>26-02-23 (v11)</h4>
  <ul>
    <li><strong>MIT Control Mode 추가</strong> &mdash; CubeMars AK 시리즈 호환 임피던스 제어. <code>0xC0</code> (MIT Control), <code>0xC1</code> (Enter Motor Mode), <code>0xC2</code> (Exit Motor Mode), <code>0xC3</code> (Set Zero Position)</li>
    <li><strong>MIT 임피던스 제어 공식</strong> &mdash; <code>iq = Kp&times;(p_des &minus; p_act) + Kd&times;(v_des &minus; v_act) + i_ff</code>. FOC ISR 내부에서 ~10kHz로 실행.</li>
    <li><strong>7-byte 비트 패킹</strong> &mdash; 위치(16bit) + 속도(12bit) + Kp(12bit) + Kd(8bit) + torque_ff(8bit) = 56bit = 7 bytes. RMD 프레임 호환 (data8[0]=cmd, data8[1-7]=MIT data).</li>
    <li><strong>Duty Closed-Loop 추가</strong> &mdash; <code>0xA5</code> Duty 제어. int16 (scale 1/10000, &minus;1.0~1.0). PWM Duty를 직접 설정.</li>
  </ul>
</div>

<!-- ============================================================ -->
<!-- GENERAL -->
<!-- ============================================================ -->
<h2>General <span class="new-badge">NEW in v9</span></h2>

<table class="general-table">
  <tr><th>Item</th><th>Value</th></tr>
  <tr><td>CAN ID</td><td><code>0x140 + Motor_ID</code></td></tr>
  <tr><td>Frame Type</td><td>Standard (SID)</td></tr>
  <tr><td>DLC</td><td>8 bytes (fixed)</td></tr>
  <tr><td>Byte Order</td><td>Little-Endian</td></tr>
</table>

<h3>Motor Status Response Format <span class="new-badge">NEW in v9</span></h3>
<p class="cmd-desc">공통 응답 포맷 &mdash; <code>0xA1</code>~<code>0xA4</code>, <code>0x9C</code>, <code>0xC0</code> 명령에 공통 적용</p>

<table>
  <tr>
    <th>Byte</th><th>Field</th><th>Type</th><th>Unit</th><th>Note</th>
  </tr>
  <tr><td><code>DATA[0]</code></td><td>Command ID</td><td>uint8</td><td>&mdash;</td><td>Echo</td></tr>
  <tr><td><code>DATA[1]</code></td><td>Motor Temperature</td><td>int8</td><td>1 &deg;C / LSB</td><td></td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Torque Current (Iq)</td><td>int16</td><td>&minus;2048~2048 = &minus;33A~33A</td><td></td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Motor Speed</td><td>int16</td><td>1 dps / LSB</td><td></td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Encoder Position</td><td>uint16</td><td>14-bit, offset applied</td><td>CNT2DEG = 360/16384</td></tr>
</table>

<!-- ============================================================ -->
<!-- TX/RX SUMMARY -->
<!-- ============================================================ -->
<h2>TX CAN Protocols Summary</h2>
<p class="cmd-desc">Command Message for controller (Message ID = 0x140 + Motor ID)</p>

<table style="font-size: 12px;">
  <tr>
    <th>Description</th><th>DATA[0]</th><th>DATA[1]</th><th>DATA[2]</th><th>DATA[3]</th><th>DATA[4]</th><th>DATA[5]</th><th>DATA[6]</th><th>DATA[7]</th>
  </tr>
  <tr><td>Read PID data</td><td>0x30</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Write PID to ROM</td><td>0x32</td><td>NULL</td><td colspan="2">Position loop Kp</td><td colspan="2">Position loop Ki</td><td colspan="2">Position loop Kd</td></tr>
  <tr><td>Read encoder data</td><td>0x90</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Write encoder offset</td><td>0x91</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td colspan="2">Encoder offset</td></tr>
  <tr><td>Write current pos as zero</td><td>0x19</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Read multi turns angle</td><td>0x92</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr class="new-row"><td><strong>Read Motor Status 2</strong></td><td>0x9C</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr class="new-row"><td><strong>Read Motor Status 3</strong></td><td>0x9D</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Motor off</td><td>0x80</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Motor stop</td><td>0x81</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Motor running</td><td>0x88</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Torque closed-loop</td><td>0xA1</td><td>NULL</td><td>NULL</td><td>NULL</td><td colspan="2">Torque current ctrl</td><td colspan="2">Damping Const</td></tr>
  <tr><td>Speed closed-loop</td><td>0xA2</td><td><strong>speed_mode</strong></td><td>NULL</td><td>NULL</td><td colspan="4">speed control (int32)</td></tr>
  <tr><td>Position closed-loop 1</td><td>0xA3</td><td>NULL</td><td>NULL</td><td>NULL</td><td colspan="4">Position control (int32)</td></tr>
  <tr><td>Set Multiturn position</td><td>0xA4</td><td>NULL</td><td colspan="2">Speed limit</td><td colspan="4">Position control (int32)</td></tr>
  <tr class="new-row"><td><strong>Duty Closed-Loop</strong></td><td>0xA5</td><td>NULL</td><td>NULL</td><td>NULL</td><td colspan="2">Duty (int16)</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Read Fault Code</td><td>0xB0</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Read Max Current</td><td>0xB1</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr><td>Write Max Current to ROM</td><td>0xB2</td><td>oc_mode</td><td colspan="2">Motor Curr. Max</td><td colspan="2">Motor Curr. Abs Max</td><td colspan="2">Bat Curr. Max</td></tr>
  <tr class="new-row"><td><strong>MIT Control</strong></td><td>0xC0</td><td colspan="2">p_des (16bit)</td><td>v_hi (8bit)</td><td>v_lo4|kp_hi4</td><td>kp_lo (8bit)</td><td>Kd (8bit)</td></tr>
  <tr class="new-row"><td><strong>MIT Enter Motor Mode</strong></td><td>0xC1</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr class="new-row"><td><strong>MIT Exit Motor Mode</strong></td><td>0xC2</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
  <tr class="new-row"><td><strong>MIT Set Zero Position</strong></td><td>0xC3</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td><td>NULL</td></tr>
</table>

<h2>RX CAN Protocols Summary</h2>

<table style="font-size: 12px;">
  <tr>
    <th>Description</th><th>DATA[0]</th><th>DATA[1]</th><th>DATA[2]</th><th>DATA[3]</th><th>DATA[4]</th><th>DATA[5]</th><th>DATA[6]</th><th>DATA[7]</th>
  </tr>
  <tr><td>Read PID data</td><td>0x30</td><td>0x00</td><td colspan="2">Position loop Kp</td><td colspan="2">Position loop Ki</td><td colspan="2">Position loop Kd</td></tr>
  <tr><td>Write PID to ROM</td><td>0x32</td><td>0x00</td><td colspan="2">Position loop Kp</td><td colspan="2">Position loop Ki</td><td colspan="2">Position loop Kd</td></tr>
  <tr><td>Read encoder data</td><td>0x90</td><td>Motor_temp</td><td colspan="2">Encoder position</td><td colspan="2">Encoder original</td><td colspan="2">Encoder offset</td></tr>
  <tr><td>Write encoder offset</td><td>0x91</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td colspan="2">Encoder offset</td></tr>
  <tr><td>Write current pos as zero</td><td>0x19</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td colspan="2">Encoder offset</td></tr>
  <tr><td>Read multi turns angle</td><td>0x92</td><td colspan="7">Multi-turn Angle (7 bytes LE)</td></tr>
  <tr class="new-row"><td><strong>Read Motor Status 2</strong></td><td>0x9C</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr class="new-row"><td><strong>Read Motor Status 3</strong></td><td>0x9D</td><td>Control Mode</td><td colspan="2">Phase A Curr</td><td colspan="2">Phase B Curr</td><td colspan="2">Phase C Curr</td></tr>
  <tr><td>Motor off</td><td>0x80</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr>
  <tr><td>Motor stop</td><td>0x81</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr>
  <tr><td>Motor running</td><td>0x88</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr>
  <tr><td>Torque closed-loop</td><td>0xA1</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr><td>Speed closed-loop</td><td>0xA2</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr><td>Position closed-loop 1</td><td>0xA3</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr><td>Set Multiturn position</td><td>0xA4</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr class="new-row"><td><strong>Duty Closed-Loop</strong></td><td>0xA5</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr><td>Read Fault Code</td><td>0xB0</td><td>Code1</td><td>Code2</td><td>Code3</td><td>Code4</td><td>Code5</td><td>Code6</td><td>Code7</td></tr>
  <tr><td>Read Max Current</td><td>0xB1</td><td>oc_mode</td><td colspan="2">Motor Curr. Max</td><td colspan="2">Motor Curr. Abs Max</td><td colspan="2">Bat Curr. Max</td></tr>
  <tr><td>Write Max Current to ROM</td><td>0xB2</td><td>oc_mode</td><td colspan="2">Motor Curr. Max</td><td colspan="2">Motor Curr. Abs Max</td><td colspan="2">Bat Curr. Max</td></tr>
  <tr class="new-row"><td><strong>MIT Control</strong></td><td>0xC0</td><td>Motor_temp</td><td colspan="2">Torque Current</td><td colspan="2">Speed</td><td colspan="2">Encoder Pos</td></tr>
  <tr class="new-row"><td><strong>MIT Enter Motor Mode</strong></td><td>0xC1</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr>
  <tr class="new-row"><td><strong>MIT Exit Motor Mode</strong></td><td>0xC2</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr>
  <tr class="new-row"><td><strong>MIT Set Zero Position</strong></td><td>0xC3</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td><td>0x00</td></tr>
</table>

<!-- ============================================================ -->
<!-- COMMAND SUMMARY -->
<!-- ============================================================ -->
<h2>Command Summary <span class="new-badge">NEW in v9</span></h2>

<table class="summary-table">
  <tr>
    <th>ID</th><th>Command</th><th>Type</th><th>Returns Status?</th>
  </tr>
  <tr><td><code>0x30</code></td><td>Read PID Data</td><td class="type-read">Read</td><td>No (PID gains)</td></tr>
  <tr><td><code>0x32</code></td><td>Write PID to ROM</td><td class="type-write">Write</td><td>No (echo)</td></tr>
  <tr><td><code>0x90</code></td><td>Read Encoder Data</td><td class="type-read">Read</td><td>No (encoder only)</td></tr>
  <tr><td><code>0x91</code></td><td>Write Encoder Offset</td><td class="type-write">Write</td><td>No (echo)</td></tr>
  <tr><td><code>0x19</code></td><td>Write Current Pos as Zero</td><td class="type-write">Write</td><td>No (offset)</td></tr>
  <tr><td><code>0x92</code></td><td>Read Multi-Turn Angle</td><td class="type-read">Read</td><td>No (angle only)</td></tr>
  <tr class="new-row"><td><code>0x9C</code></td><td>Read Motor Status 2 &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-read">Read</td><td><strong>Yes</strong></td></tr>
  <tr class="new-row"><td><code>0x9D</code></td><td>Read Motor Status 3 &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-read">Read</td><td><strong>Yes (phase currents)</strong></td></tr>
  <tr><td><code>0x80</code></td><td>Motor Off</td><td class="type-control">Control</td><td>No (ACK)</td></tr>
  <tr><td><code>0x81</code></td><td>Motor Stop</td><td class="type-control">Control</td><td>No (ACK)</td></tr>
  <tr><td><code>0x88</code></td><td>Motor Running (Start)</td><td class="type-control">Control</td><td>No (ACK)</td></tr>
  <tr><td><code>0xA1</code></td><td>Torque Closed-Loop</td><td class="type-control">Control</td><td><strong>Yes</strong></td></tr>
  <tr><td><code>0xA2</code></td><td>Speed Closed-Loop</td><td class="type-control">Control</td><td><strong>Yes</strong></td></tr>
  <tr><td><code>0xA3</code></td><td>Position Closed-Loop 1</td><td class="type-control">Control</td><td><strong>Yes</strong></td></tr>
  <tr><td><code>0xA4</code></td><td>Set Multiturn Position</td><td class="type-control">Control</td><td><strong>Yes</strong></td></tr>
  <tr class="new-row"><td><code>0xA5</code></td><td>Duty Closed-Loop &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-control">Control</td><td><strong>Yes</strong></td></tr>
  <tr><td><code>0xB0</code></td><td>Read Fault Code</td><td class="type-read">Read</td><td>No (fault codes)</td></tr>
  <tr><td><code>0xB1</code></td><td>Read Max Current</td><td class="type-read">Read</td><td>No (current limits)</td></tr>
  <tr><td><code>0xB2</code></td><td>Write Max Current to ROM</td><td class="type-write">Write</td><td>No (echo)</td></tr>
  <tr class="new-row"><td><code>0xC0</code></td><td>MIT Control &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-control">Control</td><td><strong>Yes</strong></td></tr>
  <tr class="new-row"><td><code>0xC1</code></td><td>MIT Enter Motor Mode &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-control">Control</td><td>No (ACK)</td></tr>
  <tr class="new-row"><td><code>0xC2</code></td><td>MIT Exit Motor Mode &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-control">Control</td><td>No (ACK)</td></tr>
  <tr class="new-row"><td><code>0xC3</code></td><td>MIT Set Zero Position &nbsp;<span style="color:#28a745; font-size:11px;">NEW</span></td><td class="type-write">Write</td><td>No (ACK)</td></tr>
</table>

<!-- ============================================================ -->
<!-- COMMAND DETAILS -->
<!-- ============================================================ -->
<h2>Command Details</h2>

<!-- 0x30 -->
<hr>
<h3><span class="cmd-id">0x30</span> Read PID Data</h3>
<p class="cmd-desc">Read position PID gains.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Scale</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0x30</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1]</code></td><td>0x00</td><td>&mdash;</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Kp</td><td>int16</td><td>&times;1000 (0.001/LSB)</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Ki</td><td>int16</td><td>&times;100000 (0.00001/LSB)</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Kd</td><td>int16</td><td>&times;100000 (0.00001/LSB)</td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터 Position Control 시 사용하는 PID Gain 값으로 RMD x6-s2(36:1) 모터의 Default 값은 아래와 같다.<br>
  Kp = 0.02 &nbsp;|&nbsp; Ki = 0.0002 &nbsp;|&nbsp; Kd = 0.0002
</div>

<!-- 0x32 -->
<hr>
<h3><span class="cmd-id">0x32</span> Write PID to ROM</h3>
<p class="cmd-desc">Write position PID gains to EEPROM (persistent).</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x32, 0x00, Kp_lo, Kp_hi, Ki_lo, Ki_hi, Kd_lo, Kd_hi]</div>

<p><strong>RX:</strong> Echo of TX</p>
<div class="warning">Do NOT send faster than 100Hz (EEPROM write latency).</div>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터 Position Control 시 사용하는 PID Gain 값을 모터제어기 Microprocessor의 EEPROM에 저장한다. 저장된 값은 전원이 꺼진 이후에도 사라지지 않고 유지된다. 다만, Firmware를 VESC-Tool로 업데이트한 경우 EEPROM 값이 초기화된다.<br>
  <strong>주의:</strong> EEPROM의 경우, 저장하는데 소요되는 시간이 있어 본 명령을 100Hz 이상 빠르게 반복해서 보내는 것은 지양해야 한다.
</div>

<!-- 0x90 -->
<hr>
<h3><span class="cmd-id">0x90</span> Read Encoder Data</h3>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0x90</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1]</code></td><td>Motor Temp</td><td>int8</td><td>1 &deg;C / LSB</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Encoder Position</td><td>uint16</td><td>original &minus; offset</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Encoder Original</td><td>uint16</td><td>raw (0&ndash;360&deg;)</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Encoder Offset</td><td>uint16</td><td></td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터 엔코더 데이터로 Magnetic 엔코더의 결과값에 해당한다. Magnetic 엔코더의 특성상 Encoder original position 값은 0~360도 값이 출력된다. Encoder offset 값은 사용자가 지정한 offset값으로 0~360도 값에 해당한다. Encoder Position 값은 Encoder original position에서 Encoder offset 값을 뺀 값이다.<br><br>
  <strong>예시:</strong> Encoder offset = 100도이고 Encoder original position이 260도이면 Encoder position은 160도가 출력된다. 이 경우, Encoder original position이 0~360도 범위에서 값을 가지고 Encoder offset = 100도 이기 때문에 Encoder position 값은 -100~260도 범위를 가짐을 유념해야한다.
</div>

<!-- 0x91 -->
<hr>
<h3><span class="cmd-id">0x91</span> Write Encoder Offset</h3>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x91, 0x00, 0x00, 0x00, 0x00, 0x00, Offset_lo, Offset_hi]</div>

<p><strong>RX:</strong> Echo of TX</p>
<div class="warning">Do NOT send faster than 100Hz.</div>

<div class="note-box">
  <div class="note-title">부연설명</div>
  Encoder offset 값은 사용자가 지정한 offset 값으로 DEG 값으로 0~360 범위에 있고 EEPROM에 저장되며 전원이 나가도 유지된다. VESC-Tool로 펌웨어를 업데이트한 경우 EEPROM이 초기화 된다. 다만, 펌웨어 업데이트를 VESC-Tool이 아닌 ST-Link로 JTAG Port를 통해서 하면 EEPROM 값이 유지된다.<br>
  <strong>주의:</strong> EEPROM의 경우, 저장하는데 소요되는 시간이 있어 본 명령을 100Hz 이상 빠르게 반복해서 보내는 것은 지양해야 한다.
</div>

<!-- 0x19 -->
<hr>
<h3><span class="cmd-id">0x19</span> Write Current Position to ROM as Motor Zero</h3>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<div class="tx-frame"><span class="tx-label">RX:</span> [0x19, 0x00, 0x00, 0x00, 0x00, 0x00, Offset_lo, Offset_hi]</div>

<div class="warning">Do NOT send faster than 100Hz.</div>

<div class="note-box">
  <div class="note-title">부연설명</div>
  Encoder offset 값을 지정하여 EEPROM에 저장시킨다. 로봇을 정해진 원점에 위치시키고 본 명령어를 이용하여 그 위치를 Offset으로 지정시키면 Encoder position과 Multi-turn Angle이 그 위치에서 0도가 된다. 본 값은 전원이 꺼진 이후에도 유지되며 단, VESC-Tool을 이용한 펌웨어 업데이트를 하면 초기화된다.<br>
  <strong>주의:</strong> EEPROM의 경우, 저장하는데 소요되는 시간이 있어 본 명령을 100Hz 이상 빠르게 반복해서 보내는 것은 지양해야 한다.
</div>

<!-- 0x92 -->
<hr>
<h3><span class="cmd-id">0x92</span> Read Multi-Turn Angle</h3>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0x92</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1-7]</code></td><td>Motor Angle</td><td>int64 (7 bytes LE)</td><td>0.01 deg/LSB, cumulative</td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명</div>
  Encoder 값을 누적시켜 Multi-turn Angle 값을 DEG 값으로 출력한다. 본 값은 Encoder offset 값을 적용하여 계산되며 전원이 꺼진 이후에도 저장된다. 단, VESC-Tool을 이용한 펌웨어 업데이트시 초기화 된다.
</div>

<!-- 0x9C NEW -->
<hr>
<h3><span class="cmd-id">0x9C</span> Read Motor Status 2 <span class="new-badge">NEW in v9</span></h3>
<p class="cmd-desc">Read-only status query. Returns same motor status format as 0xA1~0xA4 without commanding any motion. Safe for continuous polling.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong> Standard Motor Status Response format</p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Unit</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0x9C</td><td>uint8</td><td>&mdash;</td><td>Echo</td></tr>
  <tr><td><code>DATA[1]</code></td><td>Motor Temperature</td><td>int8</td><td>1 &deg;C / LSB</td><td></td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Torque Current (Iq)</td><td>int16</td><td>&minus;2048~2048 = &minus;33A~33A</td><td></td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Motor Speed</td><td>int16</td><td>1 dps / LSB</td><td></td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Encoder Position</td><td>uint16</td><td>14-bit, offset applied</td><td>CNT2DEG = 360/16384</td></tr>
</table>

<div class="new-box">
  <strong>Use case:</strong> Real-time monitoring, data logging, graph plotting. Can be sent at high rates (up to 1 kHz) without affecting motor operation.
</div>

<!-- 0x9D NEW -->
<hr>
<h3><span class="cmd-id">0x9D</span> Read Motor Status 3 <span class="new-badge">NEW in v9</span></h3>
<p class="cmd-desc">Read-only status query returning <strong>control mode</strong> and <strong>phase currents</strong> (A/B/C).
Based on RMD protocol 0x9D with <code>control_mode</code> added in DATA[1] (originally NULL).</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x9D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Unit</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0x9D</td><td>uint8</td><td>&mdash;</td><td>Echo</td></tr>
  <tr style="background: var(--new-bg);"><td><code>DATA[1]</code></td><td><strong>Control Mode</strong></td><td>uint8</td><td>enum</td><td>See table below</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Phase A Current</td><td>int16</td><td>1A / 64 LSB</td><td>iA = i_alpha</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Phase B Current</td><td>int16</td><td>1A / 64 LSB</td><td>iB = &minus;0.5&middot;i_alpha + &radic;3/2&middot;i_beta</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Phase C Current</td><td>int16</td><td>1A / 64 LSB</td><td>iC = &minus;(iA + iB)</td></tr>
</table>

<p style="margin-top: 12px;"><strong>Control Mode Values:</strong></p>
<table>
  <tr><th style="width:60px;">Value</th><th style="width:200px;">Mode</th><th>CAN Command Origin</th></tr>
  <tr><td>0</td><td>NONE_CONTROL</td><td>Initial state</td></tr>
  <tr><td>1</td><td>MOTOR_RELEASE</td><td>0x80 Motor Off</td></tr>
  <tr><td>2</td><td>CURRENT_BRAKE</td><td>Current brake</td></tr>
  <tr><td>3</td><td>DUTY_CONTROL</td><td>0x88 Motor Start</td></tr>
  <tr><td>4</td><td>CURRENT_CONTROL</td><td>0xA1 Torque</td></tr>
  <tr><td>5</td><td>DAMPED_CURRENT_CONTROL</td><td>0xA1 w/ damping_kd</td></tr>
  <tr style="background: #dbeafe;"><td><strong>7</strong></td><td><strong>POSITION_CONTROL_ACCUM</strong></td><td><strong>0xA3 Direct PID</strong></td></tr>
  <tr><td>8</td><td>DPS_CONTROL_TIMEOUT</td><td>Speed timeout</td></tr>
  <tr><td>9</td><td>DPS_CONTROL_DURATION</td><td>0xA2 Speed (mode=0) / 0x81 Stop</td></tr>
  <tr style="background: #dbeafe;"><td><strong>10</strong></td><td><strong>SERVO_CONTROL</strong></td><td><strong>0xA4 / or_limit redirect</strong></td></tr>
  <tr><td>11</td><td>TRAJ_CONTROL</td><td>Trajectory</td></tr>
</table>

<div class="new-box">
  <strong>Use case:</strong> Control mode monitoring (or_limit mode transitions, Direct PID &harr; Servo),
  phase current analysis. Polled alongside 0x9C for combined status + phase data.
  or_limit redirect visible as 10&rarr;7 (SERVO&rarr;Direct PID) transition on control mode graph.
</div>

<!-- 0x80 -->
<hr>
<h3><span class="cmd-id">0x80</span> Motor Off</h3>
<p class="cmd-desc">Turns off motor output, clears operating state and accumulated position.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<p><strong>RX:</strong> Echo (all zeros)</p>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터제어를 위한 모든 명령을 OFF 상태로 만든다. 모터를 Free 한 상태로 Release 한다.
</div>

<!-- 0x81 -->
<hr>
<h3><span class="cmd-id">0x81</span> Motor Stop</h3>
<p class="cmd-desc">Stops motor (speed = 0) but retains operating state. Can be resumed.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<p><strong>RX:</strong> Echo (all zeros)</p>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터를 SPEED = 0 상태로 제어하여 모터가 멈추도록 한다. 단, 이는 위치제어가 아닌 속도제어를 이용하기 때문에 외력이 크게 가해지면 자기 위치를 유지하지 않고 damping이 큰 상태로 천천히 움직일 수 있다. 그러므로 만약, 모터의 완전한 Position Lock을 하기 원한다면 SET Multiturn POS를 이용해야 한다.
</div>

<!-- 0x88 -->
<hr>
<h3><span class="cmd-id">0x88</span> Motor Running (Start)</h3>
<p class="cmd-desc">Resume from stop state. Sets duty = 0 (brake mode).</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<p><strong>RX:</strong> Echo (all zeros)</p>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터를 Duty = 0 상태로 만든다. Duty = 0 상태는 약간의 Damping 이 들어간 상태로 생각하면 된다. RMD 제어 프로토콜을 따라서 만들기는 했으나, OpenRobot MC 제어기에서는 그다지 쓰임새가 없는 제어상태라고 볼 수 있다. 일종의 Brake 상태라고 볼 수는 있다.
</div>

<!-- 0xA1 -->
<hr>
<h3><span class="cmd-id">0xA1</span> Torque Closed-Loop</h3>

<p><strong>TX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xA1</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1]</code></td><td>0x00</td><td>&mdash;</td><td>reserved</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>0x0000</td><td>&mdash;</td><td>reserved</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>iqControl</td><td>int16</td><td>&minus;2048~2048 = &minus;33A~33A</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>damping_kd</td><td>int16</td><td>0~100 (100 = max damping)</td></tr>
</table>

<div class="formula">Current = iqControl + damping_kd &times; motor_speed_rps</div>

<p><strong>RX:</strong> Motor Status Response Format</p>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터 전류제어 Loop으로 다음 식으로 제어한다.<br>
  <code>Current = (Torque current control value) + (Damping Constant value) &times; (motor_speed_rps)</code><br><br>
  Damping 토크 기능을 추가하였으며 Damping의 크기는 Damping Constant(0~100의 값)로 지정하며 100이 가장 Damping이 크다. RMD x6-s2 (36:1) 모터의 경우, 10정도가 Default 값으로 적당했다.<br>
  <strong>주의:</strong> Return 데이터중 Encoder position은 offset 값이 적용된 값이다.
</div>

<!-- 0xA2 -->
<hr>
<h3><span class="cmd-id">0xA2</span> Speed Closed-Loop <span class="new-badge">UPDATED v9</span></h3>
<p class="cmd-desc">Supports two speed control modes selectable via DATA[1].</p>

<p><strong>TX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xA2</td><td>uint8</td><td>&mdash;</td></tr>
  <tr style="background: var(--new-bg);"><td><code>DATA[1]</code></td><td><strong>speed_mode</strong></td><td>uint8</td><td>0 = DPS (default), 1 = eRPM</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>0x0000</td><td>&mdash;</td><td>reserved</td></tr>
  <tr><td><code>DATA[4-7]</code></td><td>speedControl</td><td>int32</td><td>mode 0: 0.01 dps/LSB, mode 1: 1 eRPM/LSB</td></tr>
</table>

<p style="margin-top: 12px;"><strong>speed_mode values:</strong></p>
<table>
  <tr><th style="width:60px;">Value</th><th style="width:80px;">Mode</th><th>Control Loop</th><th>Unit</th><th>Description</th></tr>
  <tr><td>0</td><td>DPS</td><td>OpenRobot custom</td><td>0.01 dps/LSB</td><td>위치제어 기반 사다리꼴 프로파일 속도제어 (기본값)</td></tr>
  <tr style="background: var(--new-bg);"><td>1</td><td>eRPM</td><td>VESC built-in PID</td><td>1 eRPM/LSB</td><td>VESC 내장 PID 속도제어 루프 (<code>mc_interface_set_pid_speed</code>)</td></tr>
</table>

<p><strong>RX:</strong> Motor Status Response Format (동일)</p>

<div class="note-box">
  <div class="note-title">부연설명 &mdash; Mode 0: DPS 제어 (기본값)</div>
  모터 속도제어 Loop으로 Degree/sec 속도값을 보낸다. 일명 DPS 제어라고 불리는 제어방식을 사용하며 일반적인 속도제어와는 다르게 위치제어를 기반으로 한 속도제어를 수행한다. 이는 위치제어를 하는 과정에서 위치 목표값을 주어진 속도 reference 를 따라갈 수 있도록 사다리꼴 Profile을 이용하여 제어한다.<br><br>
  기본적으로 위치제어 상태에서 속도를 제어하기 때문에 매우 저속에서부터 고속까지 정확한 속도제어가 가능하다. 다만, 고속의 속도제어의 경우, 위치제어의 PID Gain 값에 따라 제어 안정성 (Overshoot 등)에 차이가 있는데 RMD x6-s2 (36:1) 모터의 경우 0~8000 DPS 값에 대해서는 안정적으로 작동한다.<br>
  <strong>주의:</strong> 사다리꼴 Profile에서는 가속도값과 최대 속도값을 지정할 수 있는데 이는 펌웨어 상에 일반적으로 적당한 값으로 세팅되어 있으나 모터에 따라 별도의 튜닝이 필요할 수 있다.
</div>

<div class="note-box">
  <div class="note-title">부연설명 &mdash; Mode 1: eRPM 제어 (VESC 내장) <span class="new-badge">NEW in v9</span></div>
  VESC에 기본 탑재된 PID 속도제어 루프를 사용한다. eRPM (electrical RPM) 단위로 속도 명령을 보내며, VESC-Tool의 Speed PID 설정(Kp, Ki, Kd 등)에 의해 제어 성능이 결정된다. DPS 모드와 달리 위치제어 기반이 아닌 순수 속도 PID 제어이므로, 고속 영역에서의 응답 특성이 다르다.<br><br>
  VESC timeout 메커니즘이 적용되므로 주기적으로 명령을 보내거나, 1회 전송 후 유지되도록 설정해야 한다.
</div>

<div class="new-box">
  <strong>하위 호환:</strong> 기존 DATA[1]=0x00으로 전송하던 코드는 변경 없이 DPS 모드(mode=0)로 동작합니다.
</div>

<!-- 0xA3 -->
<hr>
<h3><span class="cmd-id">0xA3</span> Position Closed-Loop 1 <span style="font-size:13px; color:var(--text-light);">(Multi-turn, Direct PID)</span> <span class="new-badge" style="background:#e67e22;">UPDATED v9</span></h3>
<p class="cmd-desc">Direct position PID control. <strong>No velocity limiting</strong> &mdash; large steps cause full current output immediately.</p>

<p><strong>TX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xA3</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1-3]</code></td><td>0x000000</td><td>&mdash;</td><td>reserved</td></tr>
  <tr><td><code>DATA[4-7]</code></td><td>angleControl</td><td>int32</td><td>0.01 deg / LSB</td></tr>
</table>

<p><strong>RX:</strong> Motor Status Response Format</p>

<div class="warning">
  <strong>WARNING <span class="new-badge">NEW in v9</span>:</strong> No velocity ramping. Large position jumps cause instantaneous max current output, which can damage DRV/FET.
  Use <code>or_limit</code> safety limiter <span class="new-badge">NEW in v9</span> or prefer <code>0xA4</code> for large moves.
</div>

<div class="note-box">
  <div class="note-title">부연설명</div>
  Encoder offset를 고려한 위치에 대해 Multi-turn 위치제어를 수행한다. DPS_LIMIT 없이 PID제어가 직접적으로 적용되는 방식임.<br><br>
  <strong>(v8 변경사항)</strong> Set multiturn pos 를 이용한 위치제어가 offset error 가 해결될 수 없는 구조로 되어 있음을 발견, 이를 해결하기위해 Position closed-loop1 을 multiturn 방식으로 바꾸고, dps_limit 없이 직접 PID 제어되도록 수정함. &rarr; PID 제어시에는 Position closed-loop1 을 사용하기를 추천함.
</div>

<!-- 0xA4 -->
<hr>
<h3><span class="cmd-id">0xA4</span> Set Multiturn Position <span style="font-size:13px; color:var(--text-light);">(DPS-limited)</span></h3>
<p class="cmd-desc">Position control with velocity limiting via servo controller. Recommended for large position moves.</p>

<p><strong>TX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xA4</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1]</code></td><td>0x00</td><td>&mdash;</td><td>reserved</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>maxSpeed</td><td>uint16</td><td>1 dps / LSB (1~25000)</td></tr>
  <tr><td><code>DATA[4-7]</code></td><td>angleControl</td><td>int32</td><td>0.01 deg / LSB</td></tr>
</table>

<p><strong>RX:</strong> Motor Status Response Format</p>

<div class="note-box">
  <div class="note-title">부연설명</div>
  Encoder offset를 고려한 위치에 대해 Multi-turn 위치제어를 수행한다. 모터를 초기위치에 놓고 그 위치를 offset 값으로 지정하면 그 위치는 Multi-turn 0도 위치가 된다.<br><br>
  Multi-turn 위치제어를 하다가 바로 Torque 제어, Speed 제어로 변경이 가능하며 그 반대로 가능하다.<br>
  <strong>주의:</strong> Multi-turn 위치제어는 한번 명령이 들어가면 위치제어가 계속 유지되며 모터를 풀고자 하면 Motor Off 명령어로 Release를 해야 한다.
</div>

<!-- 0xB0 -->
<hr>
<h3><span class="cmd-id">0xB0</span> Read Fault Code</h3>

<div class="tx-frame"><span class="tx-label">TX:</span> [0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xB0</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1-7]</code></td><td>Fault codes 1~7</td><td>Oldest to newest</td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명</div>
  모터제어기 전원인가후 발생한 Fault Code를 최대 7개 값까지 읽을 수 있다. Fault Code 1이 가장 오래된 값이며, Fault Code 7이 가장 최신값이다. 7개 초과된 Fault Code 값은 누락된다.
</div>

<p style="margin-top:14px;"><strong>Fault Code Table (10진수값):</strong></p>
<table class="fault-table" style="font-size: 12px;">
  <tr><th style="width:40px;">Code</th><th>Fault</th><th style="width:40px;">Code</th><th>Fault</th></tr>
  <tr><td>0</td><td>NONE</td><td>14</td><td>FLASH_CORRUPTION</td></tr>
  <tr><td>1</td><td>OVER_VOLTAGE</td><td>15</td><td>HIGH_OFFSET_CURRENT_SENSOR_1</td></tr>
  <tr><td>2</td><td>UNDER_VOLTAGE</td><td>16</td><td>HIGH_OFFSET_CURRENT_SENSOR_2</td></tr>
  <tr><td>3</td><td>DRV</td><td>17</td><td>HIGH_OFFSET_CURRENT_SENSOR_3</td></tr>
  <tr><td>4</td><td>ABS_OVER_CURRENT</td><td>18</td><td>UNBALANCED_CURRENTS</td></tr>
  <tr><td>5</td><td>OVER_TEMP_FET</td><td>19</td><td>BRK</td></tr>
  <tr><td>6</td><td>OVER_TEMP_MOTOR</td><td>20</td><td>RESOLVER_LOT</td></tr>
  <tr><td>7</td><td>GATE_DRIVER_OVER_VOLTAGE</td><td>21</td><td>RESOLVER_DOS</td></tr>
  <tr><td>8</td><td>GATE_DRIVER_UNDER_VOLTAGE</td><td>22</td><td>RESOLVER_LOS</td></tr>
  <tr><td>9</td><td>MCU_UNDER_VOLTAGE</td><td>23</td><td>FLASH_CORRUPTION_APP_CFG</td></tr>
  <tr><td>10</td><td>BOOTING_FROM_WATCHDOG_RESET</td><td>24</td><td>FLASH_CORRUPTION_MC_CFG</td></tr>
  <tr><td>11</td><td>ENCODER_SPI</td><td>25</td><td>ENCODER_NO_MAGNET</td></tr>
  <tr><td>12</td><td>ENCODER_SINCOS_BELOW_MIN_AMPLITUDE</td><td>26</td><td>ENCODER_MAGNET_TOO_STRONG</td></tr>
  <tr><td>13</td><td>ENCODER_SINCOS_ABOVE_MAX_AMPLITUDE</td><td></td><td></td></tr>
</table>

<!-- 0xB1 -->
<hr>
<h3><span class="cmd-id">0xB1</span> Read Max Current</h3>

<div class="tx-frame"><span class="tx-label">TX:</span> [0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<p><strong>RX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xB1</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1]</code></td><td>OC_Mode</td><td>uint8</td><td>0=LIMIT, 1=LATCH, 2=REPORT, 3=DISABLED</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Motor Current Max</td><td>int16</td><td>0.01 A / LSB</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Motor Current Abs Max</td><td>int16</td><td>0.01 A / LSB</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Battery Current Max</td><td>int16</td><td>0.01 A / LSB</td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명</div>
  <strong>1. OC_Mode:</strong> DRV8301칩에서 자체적으로 제공하는 과전류(Over Current) 대처 모드 설정. 기본적으로 이 기능은 전류측정에 부정확하기 때문에 DISABLE(=3)으로 해놓는 것이 좋다.<br>
  <code>DRV8301_OC_LIMIT = 0, DRV8301_OC_LATCH_SHUTDOWN = 1, DRV8301_OC_REPORT_ONLY = 2, DRV8301_OC_DISABLED = 3</code><br><br>
  <strong>2. Motor Curr. Max:</strong> 모터 전류제어시 제한되는 전류 최대값 (양수로 설정하며 이값의 음수값이 자동으로 Motor Curr. Max Brake 값이 됨), Limit 역할을 하며 Fault Code가 발생하지는 않음<br><br>
  <strong>3. Motor Curr. Abs Max:</strong> 모터 전류제어시 절대값으로의 최대값으로 이 값이 넘으면 Fault Code 발생<br><br>
  <strong>4. Bat Curr. Max:</strong> 배터리에서 방전되는 전류의 최대값. PWM Duty가 100%일 때 Batt Curr. = Motor Curr. 인 상황이 되고, 일반적으로 PWM Duty가 낮으면 실제값은 Batt Curr. &lt; Motor Curr. 가 된다.
</div>

<!-- 0xB2 -->
<hr>
<h3><span class="cmd-id">0xB2</span> Write Max Current to ROM</h3>
<p class="cmd-desc">Same format as 0xB1 RX (with <code>0xB2</code> as DATA[0]).</p>

<p><strong>TX:</strong></p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xB2</td><td>uint8</td><td>&mdash;</td></tr>
  <tr><td><code>DATA[1]</code></td><td>OC_Mode</td><td>uint8</td><td>기본값 3 (DISABLED) 권장</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Motor Current Max</td><td>int16</td><td>0.01 A/LSB (예: 2000 = 20A)</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Motor Current Abs Max</td><td>int16</td><td>0.01 A/LSB (예: 15000 = 150A)</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Battery Current Max</td><td>int16</td><td>0.01 A/LSB (예: 9900 = 99A)</td></tr>
</table>

<p><strong>RX:</strong> Echo of TX</p>
<div class="warning">Do NOT send faster than 100Hz.</div>

<div class="note-box">
  <div class="note-title">부연설명</div>
  <strong>1. OC_Mode:</strong> 기본값으로 이 값을 3으로 해놓는 것이 좋다.<br>
  <code>DRV8301_OC_LIMIT = 0, DRV8301_OC_LATCH_SHUTDOWN = 1, DRV8301_OC_REPORT_ONLY = 2, DRV8301_OC_DISABLED = 3</code><br><br>
  <strong>2. Motor Curr. Max:</strong> 모터 전류제어시 제한되는 전류 최대값 (양수로 설정하며 이값의 음수값이 자동으로 Motor Curr. Max Brake 값이 됨)<br><br>
  <strong>3. Motor Curr. Abs Max:</strong> 모터 전류제어시 절대값으로의 최대값으로 이 값이 넘으면 Fault Code 발생<br><br>
  <strong>4. Bat Curr. Max:</strong> 배터리에서 방전되는 전류의 최대값. PWM Duty가 100%일 때 Batt Curr. = Motor Curr. 인 상황이 되고, 일반적으로 PWM Duty가 낮으면 실제값은 Batt Curr. &lt; Motor Curr. 가 된다.
</div>

<!-- 0xA5 -->
<hr>
<h3><span class="cmd-id">0xA5</span> Duty Closed-Loop <span class="new-badge">NEW in v11</span></h3>
<p class="cmd-desc">PWM Duty를 직접 설정. &minus;1.0 ~ 1.0 범위의 Duty를 int16 (scale &times;10000)으로 전송.</p>

<div class="tx-frame">
  <span class="tx-label">TX:</span> [0xA5, 0x00, 0x00, 0x00, Duty_Lo, Duty_Hi, 0x00, 0x00]
</div>

<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xA5</td><td>uint8</td><td>Command</td></tr>
  <tr><td><code>DATA[1-3]</code></td><td>Reserved</td><td>-</td><td>0x00</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Duty</td><td>int16 LE</td><td>&minus;10000 ~ 10000 (= &minus;1.0 ~ 1.0)</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Reserved</td><td>-</td><td>0x00</td></tr>
</table>

<p><strong>RX:</strong> Motor Status Response (공통 포맷 &mdash; temp, torque current, speed, encoder pos)</p>

<div class="note-box">
  <div class="note-title">부연설명</div>
  Duty 0.1 = 10% PWM. 양수는 정방향, 음수는 역방향. 속도/위치 피드백 없이 직접 PWM을 제어하므로 무부하 시 속도가 공급전압에 비례한다.
</div>

<!-- ============================================================ -->
<!-- TERMINAL COMMANDS -->
<!-- ============================================================ -->
<h2>Terminal Commands <span class="new-badge">NEW in v9</span></h2>

<h3><code>or_limit</code> &mdash; Position Command Safety Limiter <span class="new-badge">NEW in v9</span></h3>
<p class="cmd-desc">Firmware-level protection against dangerous large position jumps via <code>0xA3</code>.
Without protection, a large position step causes the PID to output maximum current instantaneously, which can trigger DRV/FET overcurrent faults.</p>

<div class="terminal">
<span class="prompt">$</span> or_limit &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Show current settings and hit log</span><br>
<span class="prompt">$</span> or_limit 0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># OFF (no limiting)</span><br>
<span class="prompt">$</span> or_limit 1 [deg] [dps] &nbsp;&nbsp;<span class="comment"># REDIRECT mode (default: 60 deg, 10000 dps)</span><br>
<span class="prompt">$</span> or_limit 2 [ramp_ms] &nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># RAMP mode (default: 5 ms)</span>
</div>

<!-- Background: Two Position Control Paths -->
<h3 style="margin-top: 24px;">Background: Two Position Control Paths</h3>

<table>
  <tr><th style="width:100px;"></th><th>0xA3 &mdash; Direct PID</th><th>0xA4 &mdash; Servo Controller</th></tr>
  <tr>
    <td><strong>Control Loop</strong></td>
    <td><code>run_pid_control_pos_accum()</code> @10kHz<br>
      <code>output = Kp&middot;e + Ki&middot;&int;e + Kd&middot;de/dt</code> &rarr; <code>iq = output &times; I_max</code></td>
    <td>Trapezoidal velocity profile generator<br>
      Speed capped at <code>Vel_maximum</code> (DPS)</td>
  </tr>
  <tr>
    <td><strong>Velocity Limit</strong></td>
    <td>None &mdash; full current immediately</td>
    <td>Yes &mdash; <code>maxSpeed</code> parameter</td>
  </tr>
  <tr>
    <td><strong>Characteristics</strong></td>
    <td>Fast response, best for small steps &amp; tracking</td>
    <td>Smooth accel/decel, safe for large moves</td>
  </tr>
</table>

<!-- Mode Details -->
<h3 style="margin-top: 24px;">Mode 1: REDIRECT &mdash; Control Path Switching</h3>
<p><strong>Intercept point:</strong> <code>app_openrobot_set_position()</code> (command reception) + control loop (auto-return)</p>

<p>When <code>|target &minus; current_pos| &gt; max_step</code>:</p>
<ul style="font-size: 14px;">
  <li>Redirects to the servo controller (0xA4 path) with DPS velocity limiting</li>
  <li>Motor follows trapezoidal velocity profile toward target</li>
  <li><strong>Auto-return:</strong> control loop monitors position error. When <code>|target &minus; current_pos| &le; max_step</code>, automatically switches back to Direct PID.</li>
</ul>

<p>This means both single-shot and repeated <code>0xA3</code> commands always end up in <strong>Direct PID at steady state</strong>:</p>

<div style="background: var(--bg-alt); border: 1px solid var(--border); border-radius: 6px; padding: 16px; margin: 12px 0; font-family: 'Consolas', monospace; font-size: 13px; line-height: 1.8;">
  0xA3 command received (target=360&deg;, current=0&deg;)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&darr;<br>
  |360 &minus; 0| = 360&deg; &gt; <strong>max_step</strong> (60&deg;) ?<br>
  &nbsp;&nbsp;YES &rarr; <strong>Servo controller</strong> (DPS-limited, trapezoidal profile)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&darr; &nbsp;motor moving toward target...<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|360 &minus; 305| = 55&deg; &le; max_step ?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YES &rarr; <strong>Auto-return to Direct PID</strong><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&darr;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Steady state: Direct PID holding at 360&deg;
</div>

<table style="margin-top: 8px;">
  <tr><th style="width:140px;">Parameter</th><th>Description</th><th>Default</th></tr>
  <tr><td><code>deg</code></td><td>Step threshold &mdash; redirect if |delta| exceeds this. Also used as auto-return threshold.</td><td>60&deg;</td></tr>
  <tr><td><code>dps</code></td><td>Max speed for servo controller redirect path</td><td>10000 dps</td></tr>
</table>

<h3 style="margin-top: 24px;">Mode 2: RAMP &mdash; PID Output Slew Rate Limiting</h3>
<p><strong>Intercept point:</strong> <code>run_pid_control_pos_accum()</code> (inside Direct PID loop @10kHz)</p>

<p>The position controller remains <strong>0xA3 Direct PID</strong>, but the PID output increase rate is clamped:</p>

<div style="background: var(--bg-alt); border: 1px solid var(--border); border-radius: 6px; padding: 16px; margin: 12px 0; font-family: 'Consolas', monospace; font-size: 13px; line-height: 1.8;">
  PID computes output (e.g., 0.85)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&darr;<br>
  |output| &gt; |prev_output| ? &nbsp;(magnitude increasing?)<br>
  &nbsp;&nbsp;YES &rarr; clamp delta to &plusmn;<strong>ramp_rate</strong> per cycle<br>
  &nbsp;&nbsp;NO &nbsp;&rarr; pass through (<strong>free braking</strong>)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&darr;<br>
  iq = output &times; motor_current_max
</div>

<ul style="font-size: 14px; margin-top: 8px;">
  <li>Only limits when |output| is <strong>increasing</strong> (away from zero)</li>
  <li><strong>Braking/convergence is unrestricted</strong> &mdash; prevents oscillation</li>
  <li>Default: 0.02/cycle &rarr; 0 to full output in 5 ms (50 cycles @10kHz)</li>
</ul>

<table style="margin-top: 8px;">
  <tr><th style="width:140px;">Parameter</th><th>Description</th><th>Default</th></tr>
  <tr><td><code>ramp_ms</code></td><td>Time for PID output to ramp from 0 to 100%</td><td>5 ms</td></tr>
</table>

<!-- Comparison Table -->
<h3 style="margin-top: 24px;">Comparison</h3>

<table>
  <tr><th></th><th>Mode 1 (REDIRECT)</th><th>Mode 2 (RAMP)</th></tr>
  <tr><td><strong>Intercept point</strong></td><td>Command reception + control loop</td><td>Direct PID loop (10kHz)</td></tr>
  <tr><td><strong>Method</strong></td><td>Switches to servo controller</td><td>Limits PID output slew rate</td></tr>
  <tr><td><strong>Position controller</strong></td><td>Servo &rarr; auto-return to Direct PID</td><td>Always Direct PID</td></tr>
  <tr><td><strong>Steady state</strong></td><td>Direct PID (auto-return)</td><td>Direct PID</td></tr>
  <tr><td><strong>Velocity profile</strong></td><td>Trapezoidal (accel&rarr;cruise&rarr;decel)</td><td>None (PID response with ramp)</td></tr>
  <tr><td><strong>Current limiting</strong></td><td>Indirect (via velocity limit)</td><td>Direct (output rate limit)</td></tr>
  <tr><td><strong>Default params</strong></td><td>60&deg; threshold, 10000 dps</td><td>5 ms (0&rarr;full)</td></tr>
  <tr><td><strong>Advantage</strong></td><td>Smooth profile, intuitive</td><td>Simple, preserves PID characteristics</td></tr>
</table>

<div class="info" style="margin-top: 12px;">
  Settings are <strong>auto-saved to EEPROM</strong> on mode change.
  Hit counter and last 10 events are logged (viewable via <code>or_limit</code>).
</div>

<!-- ============================================================ -->
<!-- MIT CONTROL PROTOCOL -->
<!-- ============================================================ -->
<h2>MIT Control Protocol <span class="new-badge">NEW in v11</span></h2>

<p>CubeMars AK 시리즈 호환 임피던스 제어 프로토콜. 로봇 관절의 컴플라이언트 제어에 사용되며, 매 제어 사이클마다 위치/속도 목표값과 강성/감쇠 게인 및 피드포워드 토크를 전송한다.</p>

<!-- ── Control Loop Architecture ── -->
<h3>Control Loop Architecture</h3>

<p>MIT 임피던스 제어는 <strong>FOC ISR 내부</strong>에서 ~10kHz 주기로 실행되며, 전류(Iq) 지령을 직접 계산한다. FOC 전류 루프의 Iq 기준값으로 작용하므로, 외부 PID를 거치지 않고 최소 지연으로 토크를 생성한다.</p>

<div class="formula">
  i<sub>q</sub> = Kp &times; (p_des &minus; p_act) + Kd &times; (v_des &minus; v_act) + i_ff
</div>

<!-- Block Diagram (HTML/CSS) -->
<div style="
  background: linear-gradient(135deg, #f0f4f8 0%, #e8eef5 100%);
  border: 1px solid #c0c8d4;
  border-radius: 10px;
  padding: 28px 20px 20px;
  margin: 16px 0;
  font-size: 13px;
  position: relative;
">
  <!-- Host Command Box -->
  <div style="text-align: center; margin-bottom: 8px;">
    <div style="
      display: inline-block;
      background: #2c3e50; color: #fff;
      padding: 10px 24px; border-radius: 8px;
      font-weight: bold; font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    ">
      CAN 0xC0 &nbsp;&mdash;&nbsp; Host (Motor Tool / 상위 제어기)
    </div>
  </div>

  <!-- Arrow down -->
  <div style="text-align: center; font-size: 18px; color: #555; line-height: 1.2;">&#9660;</div>

  <!-- 5 Parameters -->
  <div style="display: flex; justify-content: center; gap: 6px; margin: 6px 0 8px; flex-wrap: wrap;">
    <span style="background: #3498db; color: #fff; padding: 4px 10px; border-radius: 14px; font-size: 12px; font-weight: 600;">p_des</span>
    <span style="background: #3498db; color: #fff; padding: 4px 10px; border-radius: 14px; font-size: 12px; font-weight: 600;">v_des</span>
    <span style="background: #e67e22; color: #fff; padding: 4px 10px; border-radius: 14px; font-size: 12px; font-weight: 600;">Kp</span>
    <span style="background: #e67e22; color: #fff; padding: 4px 10px; border-radius: 14px; font-size: 12px; font-weight: 600;">Kd</span>
    <span style="background: #9b59b6; color: #fff; padding: 4px 10px; border-radius: 14px; font-size: 12px; font-weight: 600;">&tau;_ff</span>
  </div>

  <!-- Arrow down -->
  <div style="text-align: center; font-size: 18px; color: #555; line-height: 1.2;">&#9660;</div>

  <!-- MIT Impedance Controller -->
  <div style="
    background: #fff; border: 2px solid #2980b9;
    border-radius: 10px; padding: 16px 20px; margin: 6px auto;
    max-width: 680px;
    box-shadow: 0 2px 10px rgba(41,128,185,0.12);
  ">
    <div style="text-align: center; font-weight: bold; font-size: 15px; color: #1a5276; margin-bottom: 10px;">
      MIT Impedance Controller
    </div>
    <div style="display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; margin-bottom: 10px;">
      <!-- Spring term -->
      <div style="background: #eaf2f8; border: 1px solid #aed6f1; border-radius: 8px; padding: 8px 14px; text-align: center; min-width: 160px;">
        <div style="font-size: 11px; color: #666; margin-bottom: 2px;">Position (스프링)</div>
        <div style="font-weight: bold; color: #2471a3; font-size: 14px;">Kp &times; (p_des &minus; p_act)</div>
      </div>
      <!-- Damper term -->
      <div style="background: #fef5e7; border: 1px solid #f9e79f; border-radius: 8px; padding: 8px 14px; text-align: center; min-width: 160px;">
        <div style="font-size: 11px; color: #666; margin-bottom: 2px;">Velocity (댐퍼)</div>
        <div style="font-weight: bold; color: #b7950b; font-size: 14px;">Kd &times; (v_des &minus; v_act)</div>
      </div>
      <!-- FF term -->
      <div style="background: #f4ecf7; border: 1px solid #d2b4de; border-radius: 8px; padding: 8px 14px; text-align: center; min-width: 100px;">
        <div style="font-size: 11px; color: #666; margin-bottom: 2px;">Feedforward</div>
        <div style="font-weight: bold; color: #7d3c98; font-size: 14px;">+ i_ff</div>
      </div>
    </div>
    <div style="text-align: center; background: #fdfefe; border: 1px dashed #bbb; border-radius: 6px; padding: 6px; font-size: 13px;">
      i<sub>q</sub> = <span style="color:#2471a3; font-weight:bold;">Kp&middot;e<sub>p</sub></span> + <span style="color:#b7950b; font-weight:bold;">Kd&middot;e<sub>v</sub></span> + <span style="color:#7d3c98; font-weight:bold;">i_ff</span>
      &nbsp;&nbsp;&nbsp;
      <span style="color: #888; font-size: 11px;">Clamp: i<sub>min</sub> &le; i<sub>q</sub> &le; i<sub>max</sub></span>
    </div>
  </div>

  <!-- Arrow down -->
  <div style="text-align: center; font-size: 18px; color: #555; line-height: 1.2;">&#9660; i<sub>q</sub></div>

  <!-- FOC Current Loop -->
  <div style="
    background: #27ae60; color: #fff;
    border-radius: 8px; padding: 10px 20px;
    max-width: 280px; margin: 6px auto;
    text-align: center; font-weight: bold;
    box-shadow: 0 2px 8px rgba(39,174,96,0.2);
  ">
    FOC Current Loop<br>
    <span style="font-weight: normal; font-size: 12px; opacity: 0.9;">~10kHz ISR &mdash; Iq 기준값 직접 입력</span>
  </div>

  <!-- Arrow down -->
  <div style="text-align: center; font-size: 18px; color: #555; line-height: 1.2;">&#9660;</div>

  <!-- Motor -->
  <div style="
    background: #e74c3c; color: #fff;
    border-radius: 8px; padding: 8px 20px;
    max-width: 160px; margin: 6px auto;
    text-align: center; font-weight: bold; font-size: 14px;
    box-shadow: 0 2px 8px rgba(231,76,60,0.2);
  ">
    Motor
  </div>

  <!-- Arrow down -->
  <div style="text-align: center; font-size: 18px; color: #555; line-height: 1.2;">&#9660;</div>

  <!-- Feedback row -->
  <div style="display: flex; justify-content: center; gap: 16px; margin-top: 4px; flex-wrap: wrap;">
    <!-- p_act -->
    <div style="
      background: #fff; border: 2px solid #2ecc71; border-radius: 8px;
      padding: 8px 16px; text-align: center; min-width: 140px;
    ">
      <div style="font-size: 11px; color: #666;">Encoder (multiturn &rarr; rad)</div>
      <div style="font-weight: bold; color: #27ae60; font-size: 15px; margin-top: 2px;">p_act</div>
      <div style="font-size: 10px; color: #999; margin-top: 2px;">&#8593; feedback to controller</div>
    </div>
    <!-- v_act -->
    <div style="
      background: #fff; border: 2px solid #2ecc71; border-radius: 8px;
      padding: 8px 16px; text-align: center; min-width: 140px;
    ">
      <div style="font-size: 11px; color: #666;">FOC Speed (rad/s)</div>
      <div style="font-weight: bold; color: #27ae60; font-size: 15px; margin-top: 2px;">v_act</div>
      <div style="font-size: 10px; color: #999; margin-top: 2px;">&#8593; feedback to controller</div>
    </div>
    <!-- Status Response -->
    <div style="
      background: #fff; border: 2px solid #95a5a6; border-radius: 8px;
      padding: 8px 16px; text-align: center; min-width: 140px;
    ">
      <div style="font-size: 11px; color: #666;">CAN Response (0xC0 RX)</div>
      <div style="font-weight: bold; color: #7f8c8d; font-size: 13px; margin-top: 2px;">temp / iq / speed / pos</div>
      <div style="font-size: 10px; color: #999; margin-top: 2px;">&#8593; to Host</div>
    </div>
  </div>
</div>

<!-- ── Parameter Descriptions ── -->
<h3>Command Variables &amp; Gain Descriptions</h3>

<table>
  <tr><th>변수</th><th>단위</th><th>범위</th><th>역할</th></tr>
  <tr>
    <td><strong>p_des</strong></td><td>rad</td><td>&plusmn;12.5</td>
    <td><strong>목표 위치.</strong> 엔코더 multiturn 누적 각도(deg)를 rad로 변환한 좌표계 기준. <code>0xC3</code> Set Zero 후 0.0이 현재 위치가 된다. 양의 방향은 모터 정방향 회전.</td>
  </tr>
  <tr>
    <td><strong>v_des</strong></td><td>rad/s</td><td>&plusmn;76.0</td>
    <td><strong>목표 속도.</strong> 정지 유지 시 0, 궤적 추종 시 원하는 속도 프로파일 값. Kd와 함께 댐핑 제어에 사용.</td>
  </tr>
  <tr>
    <td><strong>Kp</strong></td><td>A/rad</td><td>0&ndash;500</td>
    <td><strong>위치 강성 (스프링 상수).</strong> 위치 오차 1 rad당 발생시킬 전류(A). 값이 클수록 단단하게 위치를 유지하고, 0이면 위치 피드백 없음. 로봇 관절의 가상 스프링 역할.<br>
    <em>예: Kp=10이면 1 rad 오차 시 10A의 복원 전류 발생.</em></td>
  </tr>
  <tr>
    <td><strong>Kd</strong></td><td>A&middot;s/rad</td><td>0&ndash;5</td>
    <td><strong>속도 감쇠 (댐퍼 상수).</strong> 속도 오차 1 rad/s당 발생시킬 전류(A). Kp와 함께 사용하면 진동을 억제하고, 단독(Kp=0)으로 사용하면 점성 마찰처럼 동작.<br>
    <em>예: Kd=0.5이면 1 rad/s 속도 오차 시 0.5A의 감쇠 전류 발생.</em></td>
  </tr>
  <tr>
    <td><strong>&tau;_ff (i_ff)</strong></td><td>A</td><td>&plusmn;33</td>
    <td><strong>피드포워드 토크 전류.</strong> 임피던스 제어와 무관하게 직접 더해지는 전류. 중력 보상, 마찰 보상, 또는 역동역학 계산 결과를 주입할 때 사용. Kp=Kd=0이면 순수 전류 제어 (<code>0xA1</code>과 동일).</td>
  </tr>
</table>

<!-- ── v_des Deep Dive ── -->
<h3>v_des 동작 원리 &mdash; 댐퍼의 기준 속도</h3>

<p>댐퍼 항 <code>Kd &times; (v_des &minus; v_act)</code>에서 <strong>v_des는 댐퍼가 허용하는 기준 속도</strong>를 설정한다. 댐퍼는 항상 v_act를 v_des 쪽으로 끌어당긴다.</p>

<!-- v_des = +5 -->
<h4 style="margin-top: 18px;">v_des = +5 rad/s &nbsp;<span style="color: var(--text-light); font-weight: normal;">(정방향으로 이동하려는 궤적)</span></h4>
<table style="font-size: 13px;">
  <tr><th>v_act</th><th>v_des &minus; v_act</th><th>Kd 항</th><th>효과</th></tr>
  <tr><td>0 (정지)</td><td>+5</td><td style="color: #27ae60; font-weight: bold;">+5Kd</td><td>정방향으로 밀어줌 (가속)</td></tr>
  <tr><td>+3 (느림)</td><td>+2</td><td style="color: #27ae60;">+2Kd</td><td>더 빠르게 가라고 보조</td></tr>
  <tr><td>+5 (정확)</td><td>0</td><td>0</td><td>완벽 &rarr; 간섭 없음</td></tr>
  <tr><td>+8 (빠름)</td><td>&minus;3</td><td style="color: #e74c3c;">&minus;3Kd</td><td>너무 빠르므로 브레이크</td></tr>
</table>

<!-- v_des = -5 -->
<h4 style="margin-top: 18px;">v_des = &minus;5 rad/s &nbsp;<span style="color: var(--text-light); font-weight: normal;">(역방향으로 이동하려는 궤적)</span></h4>
<table style="font-size: 13px;">
  <tr><th>v_act</th><th>v_des &minus; v_act</th><th>Kd 항</th><th>효과</th></tr>
  <tr><td>0 (정지)</td><td>&minus;5</td><td style="color: #e74c3c; font-weight: bold;">&minus;5Kd</td><td>역방향으로 밀어줌 (가속)</td></tr>
  <tr><td>&minus;3 (느림)</td><td>&minus;2</td><td style="color: #e74c3c;">&minus;2Kd</td><td>더 빠르게 역방향 보조</td></tr>
  <tr><td>&minus;5 (정확)</td><td>0</td><td>0</td><td>완벽 &rarr; 간섭 없음</td></tr>
  <tr><td>&minus;8 (빠름)</td><td>+3</td><td style="color: #27ae60;">+3Kd</td><td>너무 빠르므로 브레이크</td></tr>
</table>

<!-- v_des = 0 -->
<h4 style="margin-top: 18px;">v_des = 0 &nbsp;<span style="color: var(--text-light); font-weight: normal;">(가장 흔한 사용 &mdash; 정지 유지 / 위치 유지)</span></h4>
<table style="font-size: 13px;">
  <tr><th>v_act</th><th>v_des &minus; v_act</th><th>Kd 항</th><th>효과</th></tr>
  <tr><td>+5 (정방향)</td><td>&minus;5</td><td style="color: #e74c3c;">&minus;5Kd</td><td>멈춰! (역방향 전류)</td></tr>
  <tr><td>&minus;5 (역방향)</td><td>+5</td><td style="color: #27ae60;">+5Kd</td><td>멈춰! (정방향 전류)</td></tr>
  <tr><td>0 (정지)</td><td>0</td><td>0</td><td>정지 유지 &rarr; 간섭 없음</td></tr>
</table>

<div class="info" style="margin-top: 14px;">
  <strong>요약:</strong> v_des의 부호는 <strong>댐퍼가 허용하는 운동 방향</strong>을 결정한다.<br>
  &bull; <strong>양수</strong> &rarr; 정방향 운동을 허용, 편차만 보정<br>
  &bull; <strong>음수</strong> &rarr; 역방향 운동을 허용, 편차만 보정<br>
  &bull; <strong>0</strong> &rarr; 모든 운동에 저항 (순수 점성 감쇠, 위치 유지 시 Kp와 함께 사용)<br><br>
  궤적 추종 시 매 사이클 <code>p_des(t)</code>와 함께 <code>v_des(t)</code>를 업데이트하면, 댐퍼가 계획된 운동을 방해하지 않고 <strong>외란만 제거</strong>하므로 추종 정밀도가 크게 향상된다.
</div>

<!-- ── Usage Patterns ── -->
<h3>Usage Patterns</h3>

<table>
  <tr><th>사용 패턴</th><th>p_des</th><th>v_des</th><th>Kp</th><th>Kd</th><th>&tau;_ff</th><th>동작</th></tr>
  <tr>
    <td><strong>순수 토크 제어</strong></td><td>-</td><td>-</td><td>0</td><td>0</td><td>원하는 전류</td>
    <td>Kp=0, Kd=0이면 i_ff만 적용. 기존 <code>0xA1</code>과 동일.</td>
  </tr>
  <tr>
    <td><strong>위치 유지 (스프링-댐퍼)</strong></td><td>목표 위치</td><td>0</td><td>&gt;0</td><td>&gt;0</td><td>0</td>
    <td>외력에 대해 스프링처럼 복원. Kp↑ = 더 단단, Kd↑ = 진동 감소.</td>
  </tr>
  <tr>
    <td><strong>가변 임피던스</strong></td><td>목표 위치</td><td>0</td><td>가변</td><td>가변</td><td>0</td>
    <td>매 사이클 Kp/Kd를 변경하여 충격 시 유연, 정밀 작업 시 강건 전환.</td>
  </tr>
  <tr>
    <td><strong>궤적 추종</strong></td><td>궤적 p(t)</td><td>궤적 v(t)</td><td>&gt;0</td><td>&gt;0</td><td>τ(t)</td>
    <td>매 사이클 (p, v, τ)를 업데이트. 로봇 동역학 계산 기반 제어.</td>
  </tr>
  <tr>
    <td><strong>중력 보상</strong></td><td>현재 위치</td><td>0</td><td>0</td><td>0</td><td>중력 토크</td>
    <td>관절의 무게를 상쇄. 사람이 손으로 자유롭게 움직일 수 있음 (제로-G).</td>
  </tr>
  <tr>
    <td><strong>점성 감쇠 (백드라이브)</strong></td><td>-</td><td>0</td><td>0</td><td>&gt;0</td><td>0</td>
    <td>Kp=0이면 위치 구속 없이 속도에 비례하는 저항만 발생. 안전한 물리적 상호작용.</td>
  </tr>
</table>

<!-- ── Control Sequence ── -->
<h3>Typical Control Sequence</h3>

<div class="note-box">
  <div class="note-title">MIT 제어 사용 순서</div>
  <ol style="margin-top: 8px; padding-left: 20px;">
    <li><code>0xC3</code> <strong>Set Zero Position</strong> &mdash; 현재 위치를 영점으로 설정 (EEPROM 저장 + multiturn 리셋). 모터가 구동 중이면 <strong>먼저 Exit Motor Mode (0xC2)를 보낸 후</strong> Set Zero를 보내야 점프를 방지할 수 있다.</li>
    <li><code>0xC1</code> <strong>Enter Motor Mode</strong> &mdash; 모터 Enable (전류 제어 활성화)</li>
    <li><code>0xC0</code> <strong>MIT Control</strong> &mdash; 주기적 전송 (50~500Hz 권장). 매 프레임마다 5개 파라미터 업데이트.</li>
    <li><code>0xC2</code> <strong>Exit Motor Mode</strong> &mdash; 제어 종료, 모터 Release (전류 0)</li>
  </ol>
</div>

<div class="warning">
  <strong>Set Zero 주의사항:</strong> MIT 제어 도중 <code>0xC3</code>을 보내면, 엔코더가 리셋되지만 FW의 <code>m_mit_p_des</code>(이전 목표 위치)가 남아있어 모터가 급격히 회전할 수 있다. 반드시 <code>0xC2</code> (Exit) → <code>0xC3</code> (Set Zero) 순서로 전송할 것.
</div>

<!-- ── Feedback Variables ── -->
<h3>Feedback Variables (p_act, v_act)</h3>
<table>
  <tr><th>변수</th><th>소스</th><th>설명</th></tr>
  <tr>
    <td><strong>p_act</strong></td>
    <td><code>mcpwm_foc_get_pos_accum()</code> &times; &pi;/180</td>
    <td>엔코더 multiturn 누적 각도(deg)를 rad으로 변환. Offset 적용됨 (Set Zero 후 0.0). 여러 바퀴 회전 시 360&deg; 이상 누적.</td>
  </tr>
  <tr>
    <td><strong>v_act</strong></td>
    <td><code>mcpwm_foc_get_rps()</code></td>
    <td>FOC에서 계산한 현재 회전 속도 (rad/s). eRPM을 pole pair로 나눈 값을 rad/s로 변환.</td>
  </tr>
</table>

<div class="info">
  <strong>좌표계:</strong> p_act는 <code>0xC3</code> Set Zero 이후 0에서 시작하며, 정방향 회전 시 양수로 증가한다. multiturn이므로 ±12.5 rad (&approx; ±716&deg; &approx; ±2 바퀴) 범위 내에서 연속적인 위치 제어가 가능하다.
</div>

<!-- ── Parameter Encoding ── -->
<h3>MIT Parameter Encoding (7 bytes)</h3>
<p class="cmd-desc">data8[1]~data8[7]에 56-bit 비트 패킹. CubeMars 표준 인코딩 방식.</p>

<table>
  <tr><th>Field</th><th>Bits</th><th>Range</th><th>Resolution</th><th>Byte Position</th></tr>
  <tr><td>p_des (position)</td><td>16</td><td>&plusmn;12.5 rad</td><td>0.0004 rad (0.02&deg;)</td><td>DATA[1-2]</td></tr>
  <tr><td>v_des (velocity)</td><td>12</td><td>&plusmn;76 rad/s</td><td>0.037 rad/s</td><td>DATA[3] + DATA[4] hi-nibble</td></tr>
  <tr><td>Kp (stiffness)</td><td>12</td><td>0&ndash;500 A/rad</td><td>0.122</td><td>DATA[4] lo-nibble + DATA[5]</td></tr>
  <tr><td>Kd (damping)</td><td>8</td><td>0&ndash;5 A&middot;s/rad</td><td>0.020</td><td>DATA[6]</td></tr>
  <tr><td>&tau;_ff (feedforward)</td><td>8</td><td>&plusmn;33 A</td><td>0.259 A</td><td>DATA[7]</td></tr>
</table>

<div class="tx-frame">
  <span class="tx-label">Bit layout:</span> [p_hi(8)] [p_lo(8)] [v_hi(8)] [v_lo(4)|kp_hi(4)] [kp_lo(8)] [kd(8)] [tff(8)]
</div>

<!-- 0xC0 -->
<hr>
<h3><span class="cmd-id">0xC0</span> MIT Control <span class="new-badge">NEW</span></h3>
<p class="cmd-desc">MIT 임피던스 제어. 위치/속도/강성/감쇠/피드포워드 토크 5개 파라미터를 7-byte 패킹으로 전송.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0xC0, p_hi, p_lo, v_hi, v_lo4|kp_hi4, kp_lo, kd, tff]</div>

<p><strong>RX:</strong> Motor Status Response (공통 포맷)</p>
<table>
  <tr><th>Byte</th><th>Field</th><th>Type</th><th>Note</th></tr>
  <tr><td><code>DATA[0]</code></td><td>0xC0</td><td>uint8</td><td>Echo</td></tr>
  <tr><td><code>DATA[1]</code></td><td>Motor Temperature</td><td>int8</td><td>1 &deg;C / LSB</td></tr>
  <tr><td><code>DATA[2-3]</code></td><td>Torque Current (Iq)</td><td>int16</td><td>&minus;2048~2048 = &minus;33A~33A</td></tr>
  <tr><td><code>DATA[4-5]</code></td><td>Motor Speed</td><td>int16</td><td>1 dps / LSB</td></tr>
  <tr><td><code>DATA[6-7]</code></td><td>Encoder Position</td><td>uint16</td><td>14-bit, offset applied</td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명 &mdash; MIT Control 사용법</div>
  <strong>순수 토크 제어:</strong> Kp=0, Kd=0 으로 설정하면 &tau;_ff만 적용 &mdash; 기존 <code>0xA1</code>과 동일한 전류 제어.<br>
  <strong>위치 유지 (스프링-댐퍼):</strong> p_des=현재위치, v_des=0, Kp&gt;0, Kd&gt;0, &tau;_ff=0 &mdash; 관절이 외력에 대해 스프링처럼 복원.<br>
  <strong>궤적 추종:</strong> 매 사이클마다 p_des, v_des를 업데이트하면서 Kp, Kd로 임피던스 제어.<br>
  <strong>주의:</strong> p_act는 encoder accumulated position (rad 변환), v_act는 FOC에서 계산한 rad/s. 엔코더 영점(<code>0xC3</code>)을 먼저 설정해야 p_des가 의미있는 값이 됨.
</div>

<!-- 0xC1 -->
<hr>
<h3><span class="cmd-id">0xC1</span> MIT Enter Motor Mode <span class="new-badge">NEW</span></h3>
<p class="cmd-desc">모터 Enable. CubeMars 프로토콜의 Enter Motor Mode (0xFC)에 해당.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<div class="tx-frame"><span class="tx-label">RX:</span> [0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<!-- 0xC2 -->
<hr>
<h3><span class="cmd-id">0xC2</span> MIT Exit Motor Mode <span class="new-badge">NEW</span></h3>
<p class="cmd-desc">모터 Release. CubeMars 프로토콜의 Exit Motor Mode (0xFD)에 해당. 전류를 0으로 만들고 모터를 해제한다.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0xC2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<div class="tx-frame"><span class="tx-label">RX:</span> [0xC2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<!-- 0xC3 -->
<hr>
<h3><span class="cmd-id">0xC3</span> MIT Set Zero Position <span class="new-badge">NEW</span></h3>
<p class="cmd-desc">현재 위치를 영점으로 설정. CubeMars 프로토콜의 Set Zero Position (0xFE)에 해당. 엔코더 오프셋을 EEPROM에 저장하고 multi-turn 누적 각도도 리셋.</p>

<div class="tx-frame"><span class="tx-label">TX:</span> [0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>
<div class="tx-frame"><span class="tx-label">RX:</span> [0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]</div>

<div class="warning">EEPROM 쓰기 포함. 100Hz 이상 반복 전송 금지. <code>0x19</code> (Write Current Pos as Zero)와 동일한 내부 동작.</div>

<h3>CubeMars 프로토콜 매핑</h3>
<table>
  <tr><th>CubeMars 원본</th><th>OpenRobot RMD</th><th>기능</th></tr>
  <tr><td><code>0xFC</code> (CAN ID)</td><td><code>0xC1</code> (DATA[0])</td><td>Enter Motor Mode</td></tr>
  <tr><td><code>0xFD</code> (CAN ID)</td><td><code>0xC2</code> (DATA[0])</td><td>Exit Motor Mode</td></tr>
  <tr><td><code>0xFE</code> (CAN ID)</td><td><code>0xC3</code> (DATA[0])</td><td>Set Zero Position</td></tr>
  <tr><td>MIT frame (CAN ID)</td><td><code>0xC0</code> (DATA[0])</td><td>Impedance Control</td></tr>
</table>

<div class="info">
  CubeMars는 CAN ID 자체로 명령을 구분하지만, OpenRobot은 RMD 프로토콜 구조 (SID = 0x140 + motor_id, DATA[0] = command byte)를 사용하므로 명령 바이트가 다름. 비트 패킹 방식과 파라미터 범위는 CubeMars 표준과 동일.
</div>

<!-- ── Appendix: Comparison with existing control modes ── -->
<h3>부록: 기존 제어 모드와의 비교</h3>

<p>MIT 임피던스 제어가 기존 위치/속도 제어보다 구조적으로 단순하고 직접적인 이유를 비교한다.</p>

<!-- Comparison summary table -->
<table style="font-size: 13px;">
  <tr>
    <th style="width: 22%;"></th>
    <th style="width: 39%;">기존 위치 PID (0xA3 / 0xA4)</th>
    <th style="width: 39%;">MIT Control (0xC0)</th>
  </tr>
  <tr>
    <td><strong>제어 구조</strong></td>
    <td>PID (P+I+D) &rarr; 정규화 출력 (-1~1) &rarr; &times; lo_current_max</td>
    <td style="background: #d5f5e3;"><strong>PD + FF &rarr; 직접 Iq (Ampere)</strong></td>
  </tr>
  <tr>
    <td><strong>I-term (적분항)</strong></td>
    <td>있음 (windup 위험)</td>
    <td style="background: #d5f5e3;"><strong>없음</strong> (&tau;_ff로 대체)</td>
  </tr>
  <tr>
    <td><strong>D-term / 감쇠</strong></td>
    <td>오차 미분 + LP 필터</td>
    <td style="background: #d5f5e3;"><strong>실제 속도(rad/s)</strong> 직접 사용</td>
  </tr>
  <tr>
    <td><strong>출력 단위</strong></td>
    <td>정규화 비율 (-1~1)</td>
    <td style="background: #d5f5e3;"><strong>물리적 전류 (A)</strong></td>
  </tr>
  <tr>
    <td><strong>DPS 속도제어</strong></td>
    <td>프로파일 생성 &rarr; 위치 PID (이중 루프)</td>
    <td style="background: #d5f5e3;">단일 루프</td>
  </tr>
  <tr>
    <td><strong>게인 조정</strong></td>
    <td>FW에 고정 (MCCONF)</td>
    <td style="background: #d5f5e3;"><strong>매 프레임 전송</strong> (실시간 변경)</td>
  </tr>
</table>

<!-- Detail 1: Normalized output -->
<h4 style="margin-top: 20px;">1. PID 출력이 정규화된 비율 &mdash; 가장 큰 구조적 차이</h4>

<p>기존 <code>run_pid_control_pos_accum()</code>의 출력 경로:</p>
<div style="background: var(--code-bg); padding: 12px 16px; border-radius: 6px; font-family: 'Consolas', monospace; font-size: 13px; margin: 8px 0;">
  output = P + I + D; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #888;">// PID 합산</span><br>
  clamp(output, -1.0, 1.0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #888;">// <strong>-1~1 비율</strong>로 클램프</span><br>
  motor&rarr;m_iq_set = output &times; lo_current_max; <span style="color: #888;">// 비율 &times; 최대전류</span>
</div>
<p>
  <code>p_pid_kp</code>의 단위가 <strong>&ldquo;각도오차(deg)당 비율&rdquo;</strong>이므로,
  <code>lo_current_max</code>가 바뀌면 같은 Kp에서 실제 전류가 달라진다. 모터/설정마다 게인 재튜닝이 필요하며,
  I-term windup 보호도 이 비율 기준이라 미묘한 동적 문제가 발생할 수 있다.
</p>

<p>MIT 제어의 출력 경로:</p>
<div style="background: #d5f5e3; padding: 12px 16px; border-radius: 6px; font-family: 'Consolas', monospace; font-size: 13px; margin: 8px 0;">
  iq = Kp &times; (p_des &minus; p_act) + Kd &times; (v_des &minus; v_act) + i_ff; <span style="color: #888;">// <strong>바로 Ampere</strong></span><br>
  clamp(iq, lo_current_min, lo_current_max); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #888;">// 전류 리밋</span><br>
  motor&rarr;m_iq_set = iq; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #888;">// 직접 입력</span>
</div>
<p>
  정규화 없이 <strong>물리적 전류(A)</strong>를 직접 계산하므로, Kp=10이면 1 rad 오차에 10A가 발생한다는 것이 직관적이다.
  모터나 설정이 바뀌어도 물리적 의미가 유지된다.
</p>

<!-- Detail 2: I-term -->
<h4>2. I-term (적분항)의 유무</h4>
<p>
  기존 PID에는 <strong>I-term</strong>이 있다. 정지 시 오차가 남으면 I-term이 서서히 누적되다가 한계를 넘으면 한꺼번에 방출되어 <strong>오버슈트와 진동</strong>을 유발할 수 있다.
  Anti-windup 보호가 있지만 튜닝이 까다롭다.
</p>
<p>
  MIT 제어에는 <strong>I-term이 없다</strong> (순수 PD + FF). 로봇 임피던스 제어에서는 I-term 없이
  <code>&tau;_ff</code> (피드포워드 토크)로 정상상태 오차를 보상하는 것이 표준적이며, windup이 원천적으로 발생하지 않는다.
</p>

<!-- Detail 3: D-term vs velocity feedback -->
<h4>3. D-term: 오차 미분 vs 실제 속도 피드백</h4>

<div style="display: flex; gap: 16px; flex-wrap: wrap; margin: 10px 0;">
  <!-- Existing PID D-term -->
  <div style="flex: 1; min-width: 280px; background: #fef9e7; border: 1px solid #f9e79f; border-radius: 8px; padding: 12px;">
    <div style="font-weight: bold; color: #b7950b; margin-bottom: 6px;">기존 PID &mdash; 오차 미분</div>
    <div style="font-family: monospace; font-size: 12px; background: #fff; padding: 8px; border-radius: 4px;">
      d_term = (error &minus; prev_error) / dt<br>
      LP_FILTER(d_term, kd_filter)
    </div>
    <ul style="font-size: 12px; margin-top: 8px; padding-left: 18px; color: #666;">
      <li>엔코더 해상도가 낮으면 error == prev_error 구간 발생 &rarr; d_term = 0 &rarr; <strong>불연속</strong></li>
      <li>목표값 변경 시 미분 킥(derivative kick) 발생</li>
      <li>LP 필터로 완화하지만 위상 지연 추가</li>
    </ul>
  </div>
  <!-- MIT velocity feedback -->
  <div style="flex: 1; min-width: 280px; background: #d5f5e3; border: 1px solid #82e0aa; border-radius: 8px; padding: 12px;">
    <div style="font-weight: bold; color: #1e8449; margin-bottom: 6px;">MIT &mdash; 실제 속도 피드백</div>
    <div style="font-family: monospace; font-size: 12px; background: #fff; padding: 8px; border-radius: 4px;">
      Kd &times; (v_des &minus; v_act)<br>
      <span style="color: #888;">v_act = mcpwm_foc_get_rps()</span>
    </div>
    <ul style="font-size: 12px; margin-top: 8px; padding-left: 18px; color: #666;">
      <li>FOC에서 계산한 <strong>실제 속도(rad/s)</strong>를 직접 사용</li>
      <li>오차 미분 불필요 &rarr; <strong>매끄럽고 노이즈에 강건</strong></li>
      <li>목표 속도(v_des)를 별도 설정 가능 &rarr; 궤적 추종에 유리</li>
    </ul>
  </div>
</div>

<!-- Detail 4: DPS double loop -->
<h4>4. DPS 속도제어의 이중 루프</h4>
<p>
  RMD <code>0xA2</code> (DPS) 명령은 <code>dps_control_thread</code>에서 사다리꼴 속도 프로파일(<code>genProfile</code>)을 생성한 뒤,
  그 출력(deg_ref)을 다시 <strong>위치 PID</strong>에 넣는 <strong>이중 루프 (프로파일 &rarr; 위치 PID &rarr; 전류)</strong> 구조이다.
  두 루프의 게인이 서로 간섭할 수 있으며, 프로파일 생성의 이산화 오차도 누적된다.
</p>
<p>
  MIT는 <strong>단일 루프</strong>. 임피던스 법칙이 직접 Iq를 계산하므로 중간 단계가 없다.
</p>

<div class="info">
  <strong>결론:</strong> 기존 제어가 &ldquo;문제&rdquo;라기보다, MIT가 구조적으로 더 단순하고 직접적인 것이 핵심이다.<br>
  &bull; <strong>정규화 없이 물리적 전류(A) 직접 계산</strong> &rarr; 직관적 튜닝<br>
  &bull; <strong>I-term 없음</strong> &rarr; windup/오버슈트 원천 방지<br>
  &bull; <strong>실제 속도 피드백</strong> &rarr; 오차 미분보다 매끄럽고 강건<br>
  &bull; <strong>단일 루프</strong> &rarr; 이중 루프 간섭 없음<br>
  &bull; <strong>매 프레임 게인 전송</strong> &rarr; 실시간 임피던스 변경<br><br>
  로봇 관절 제어에서는 I-term 없는 PD + FF가 산업 표준이며, CubeMars/MIT Mini Cheetah 등 대부분의 로봇 액추에이터가 이 구조를 채택하고 있다.
</div>

<!-- ============================================================ -->
<!-- VESC EID PROTOCOL -->
<!-- ============================================================ -->
<h2>VESC EID Protocol <span class="new-badge">NEW in v10</span></h2>

<p>CAN Extended ID (EID)를 사용하는 VESC 내장 통신 프로토콜. SID 프로토콜과 별도로 동작하며, MCCONF/APPCONF 파라미터 설정, 펌웨어 업로드, 리부트 등에 사용된다.</p>

<h3>EID Frame Format</h3>
<table class="general-table">
  <tr><th>Item</th><th>Value</th></tr>
  <tr><td>Frame Type</td><td>Extended (EID, 29-bit)</td></tr>
  <tr><td>EID Format</td><td><code>(packet_type &lt;&lt; 8) | target_id</code></td></tr>
  <tr><td>Byte Order</td><td>Big-Endian</td></tr>
  <tr><td>PC Sender ID</td><td><code>0xFE</code> (254)</td></tr>
</table>

<div class="info">
  VESC EID는 multi-frame 프로토콜을 사용하여 8바이트 CAN 프레임 제한을 넘는 대용량 데이터를 전송한다.
  <code>FILL_RX_BUFFER</code> &rarr; <code>PROCESS_RX_BUFFER</code> 순서로 데이터를 분할/재조립한다.
</div>

<h3>VESC EID Packet Types</h3>
<table>
  <tr><th>Type</th><th>Value</th><th>Direction</th><th>Description</th></tr>
  <tr><td><code>CAN_PACKET_FILL_RX_BUFFER</code></td><td>5</td><td>TX/RX</td><td>Multi-frame 데이터 버퍼 채우기</td></tr>
  <tr><td><code>CAN_PACKET_FILL_RX_BUFFER_LONG</code></td><td>6</td><td>TX/RX</td><td>Long index (16-bit offset) 버퍼 채우기</td></tr>
  <tr><td><code>CAN_PACKET_PROCESS_RX_BUFFER</code></td><td>7</td><td>TX/RX</td><td>버퍼 처리 명령 (CRC 포함)</td></tr>
  <tr><td><code>CAN_PACKET_PROCESS_SHORT_BUFFER</code></td><td>8</td><td>TX/RX</td><td>짧은 단일 프레임 명령</td></tr>
</table>

<h3>주요 VESC Commands (CommPacketId)</h3>
<table class="summary-table">
  <tr><th>ID</th><th>Command</th><th>Type</th><th>Description</th></tr>
  <tr><td><code>0</code></td><td>COMM_FW_VERSION</td><td class="type-read">Read</td><td>펌웨어 버전 조회</td></tr>
  <tr><td><code>14</code></td><td>COMM_GET_MCCONF</td><td class="type-read">Read</td><td>Motor Configuration 읽기 (~457 bytes)</td></tr>
  <tr><td><code>13</code></td><td>COMM_SET_MCCONF</td><td class="type-write">Write</td><td>Motor Configuration 쓰기</td></tr>
  <tr><td><code>15</code></td><td>COMM_GET_MCCONF_DEFAULT</td><td class="type-read">Read</td><td>Motor Configuration 기본값 읽기</td></tr>
  <tr><td><code>17</code></td><td>COMM_GET_APPCONF</td><td class="type-read">Read</td><td>App Configuration 읽기 (~418 bytes)</td></tr>
  <tr><td><code>16</code></td><td>COMM_SET_APPCONF</td><td class="type-write">Write</td><td>App Configuration 쓰기</td></tr>
  <tr><td><code>18</code></td><td>COMM_GET_APPCONF_DEFAULT</td><td class="type-read">Read</td><td>App Configuration 기본값 읽기</td></tr>
  <tr><td><code>28</code></td><td>COMM_REBOOT</td><td class="type-control">Control</td><td>MCU 리부트 (IWDG watchdog 리셋)</td></tr>
  <tr><td><code>31</code></td><td>COMM_ERASE_NEW_APP</td><td class="type-write">Write</td><td>Staging area 삭제 (펌웨어 업로드 1단계)</td></tr>
  <tr><td><code>32</code></td><td>COMM_WRITE_NEW_APP_DATA</td><td class="type-write">Write</td><td>Staging area에 바이너리 쓰기 (2단계)</td></tr>
  <tr><td><code>36</code></td><td>COMM_JUMP_TO_BOOTLOADER</td><td class="type-control">Control</td><td>부트로더로 점프 (3단계)</td></tr>
  <tr><td><code>46</code></td><td>COMM_ERASE_BOOTLOADER</td><td class="type-write">Write</td><td>부트로더 섹터 삭제 (부트로더 업로드 시)</td></tr>
</table>

<h3>MCCONF PID Offsets</h3>
<p class="cmd-desc">MCCONF 바이너리 페이로드 내 PID 파라미터 오프셋 (MCCONF_SIGNATURE: <code>0x83C3E1AA</code>). 값은 VESC <code>float32_auto</code> 포맷 (4 bytes Big-Endian).</p>

<table>
  <tr><th>Parameter</th><th>Speed PID Offset</th><th>Position PID Offset</th></tr>
  <tr><td>Kp</td><td>329</td><td>354</td></tr>
  <tr><td>Ki</td><td>333</td><td>358</td></tr>
  <tr><td>Kd</td><td>337</td><td>362</td></tr>
  <tr><td>Kd Filter</td><td>341</td><td>366</td></tr>
  <tr><td>Ramp (eRPM/s)</td><td>350</td><td>&mdash;</td></tr>
</table>

<div class="note-box">
  <div class="note-title">부연설명 &mdash; MCCONF PID 읽기/쓰기</div>
  <strong>읽기:</strong> COMM_GET_MCCONF (14)를 전송하면 전체 MCCONF 바이너리(~457 bytes)가 반환됨. 위 오프셋에서 PID 값을 추출.<br>
  <strong>쓰기:</strong> 읽은 원본 MCCONF를 복사하고, 수정할 PID 값만 해당 오프셋에 패치한 후 COMM_SET_MCCONF (13)로 전송.<br>
  <strong>주의:</strong> 반드시 원본 MCCONF를 먼저 읽은 후(Read Gains), PID 값만 수정하여 전체를 다시 쓰는 방식을 사용해야 함. 그렇지 않으면 다른 설정값이 손상될 수 있음.
</div>

<h3>Firmware Upload via CAN EID</h3>

<div class="note-box">
  <div class="note-title">부연설명 &mdash; CAN 펌웨어/부트로더 업로드</div>
  <strong>Firmware Upload:</strong><br>
  1. <code>COMM_ERASE_NEW_APP(size)</code> &mdash; Staging area (Flash sectors 8-10) 삭제<br>
  2. <code>COMM_WRITE_NEW_APP_DATA(offset, data)</code> &mdash; 바이너리 데이터를 400-byte 청크로 분할 전송<br>
  3. <code>COMM_JUMP_TO_BOOTLOADER</code> &mdash; 부트로더가 staging &rarr; app 영역으로 복사<br><br>
  <strong>Bootloader Upload:</strong><br>
  1~2 단계 동일<br>
  3. <code>COMM_ERASE_BOOTLOADER</code> &mdash; 부트로더 섹터 (Flash sector 11, 128KB) 삭제<br>
  4. <code>COMM_JUMP_TO_BOOTLOADER</code> &mdash; staging의 부트로더가 sector 11에 자기 자신을 복사<br><br>
  <strong>주의:</strong> 부트로더 업로드 실패 시 복구 불가 (JTAG 필요). 반드시 안정적인 전원과 CAN 연결 상태에서 수행할 것.
</div>

<h3>Encoder Native Resolution <span class="new-badge">NEW in v10</span></h3>

<table>
  <tr><th>Encoder</th><th>Resolution</th><th>CPR</th><th>Note</th></tr>
  <tr><td>AS5047</td><td>14-bit</td><td>16,384</td><td>CAN SID 프레임과 동일 해상도</td></tr>
  <tr><td>MT6835</td><td>21-bit</td><td>2,097,152</td><td>CAN SID에서는 14-bit로 정규화하여 전송</td></tr>
</table>

<div class="warning">
  <strong>Overflow 주의:</strong> MT6835 21-bit 값 &times; 16384 연산 시 uint32_t 오버플로 발생 (45&deg; 이상에서).
  반드시 <code>uint64_t</code> 캐스트 사용: <code>(uint64_t)val * ENCODER_CPR_AS5047 / cpr</code>
</div>

<!-- ============================================================ -->
<!-- REVISION HISTORY -->
<!-- ============================================================ -->
<h2>Revision History</h2>

<table class="revision-table">
  <tr><th>Version</th><th>Date</th><th>Changes</th></tr>
  <tr>
    <td>v7</td>
    <td>2024-11-18</td>
    <td>Encoder offset, damping torque, fault code, current limit R/W.</td>
  </tr>
  <tr>
    <td>v8</td>
    <td>2025-05-15</td>
    <td><code>0xA3</code> changed to multi-turn direct PID. <code>0xB0</code>/<code>0xB1</code>/<code>0xB2</code> added. All control commands changed to single-shot (1회 전달 후 유지).</td>
  </tr>
  <tr>
    <td>v9</td>
    <td>2026-02-09</td>
    <td><code>0x9C</code> (Read Motor Status 2) added. <code>0x9D</code> (Read Motor Status 3: control mode + phase currents) added. <code>or_limit</code> safety limiter added. Encoder 14-bit normalization for MT6835. <code>0xA2</code> speed_mode (DPS/eRPM) added.</td>
  </tr>
  <tr>
    <td>v10</td>
    <td>2026-02-11</td>
    <td>VESC EID Protocol section added. Encoder native resolution (AS5047 14-bit / MT6835 21-bit) with uint64_t overflow fix. COMM_REBOOT HardFault bug fixed. CAN firmware/bootloader upload. Position/Speed PID via MCCONF EID.</td>
  </tr>
  <tr style="background: var(--new-bg); font-weight: 600;">
    <td>v11</td>
    <td>2026-02-23</td>
    <td>MIT Control Protocol added (0xC0~0xC3). CubeMars AK compatible impedance control: position/velocity/Kp/Kd/torque_ff packed in 7 bytes. Enter/Exit Motor Mode and Set Zero Position commands. Control loop architecture, parameter descriptions, usage patterns documented. Duty Closed-Loop (0xA5) added.</td>
  </tr>
</table>

<!-- ============================================================ -->
<!-- FOOTER -->
<!-- ============================================================ -->
<div class="doc-footer">
  OpenRobot Motor CAN Protocol &mdash; OpenRobot MC v11 &nbsp;|&nbsp; DRCL / OpenRobot &nbsp;|&nbsp; 2026-02-23
</div>

</body>
</html>
